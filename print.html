<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Adversarial CHERI Exercises and Missions</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="cover/index.html">Adversarial CHERI Exercises and Missions</a></li><li class="chapter-item expanded "><a href="introduction/index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="introduction/background.html"><strong aria-hidden="true">1.1.</strong> Background reading</a></li><li class="chapter-item expanded "><a href="introduction/cross-compilation-execution.html"><strong aria-hidden="true">1.2.</strong> Cross compilation and execution</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="introduction/ccc.html"><strong aria-hidden="true">1.2.1.</strong> Helper script</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="exercises/index.html"><strong aria-hidden="true">2.</strong> Skills Development Exercises</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="exercises/compile-and-run/index.html"><strong aria-hidden="true">2.1.</strong> Compile and run RISC-V and CHERI-RISC-V programs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="exercises/compile-and-run/answers.html"><strong aria-hidden="true">2.1.1.</strong> Answers</a></li></ol></li><li class="chapter-item expanded "><a href="exercises/debug-and-disassemble/index.html"><strong aria-hidden="true">2.2.</strong> Disassemble and debug RISC-V and CHERI-RISC-V programs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="exercises/debug-and-disassemble/answers.html"><strong aria-hidden="true">2.2.1.</strong> Answers</a></li></ol></li><li class="chapter-item expanded "><a href="exercises/cheri-tags/index.html"><strong aria-hidden="true">2.3.</strong> Demonstrate CHERI Tag Protection</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="exercises/cheri-tags/answers.html"><strong aria-hidden="true">2.3.1.</strong> Answers</a></li></ol></li><li class="chapter-item expanded "><a href="exercises/buffer-overflow-stack/index.html"><strong aria-hidden="true">2.4.</strong> Exercise an inter-object stack buffer overflow</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="exercises/buffer-overflow-stack/answers.html"><strong aria-hidden="true">2.4.1.</strong> Answers</a></li></ol></li><li class="chapter-item expanded "><a href="exercises/buffer-overflow-global/index.html"><strong aria-hidden="true">2.5.</strong> Exercise an inter-object global buffer overflow</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="exercises/buffer-overflow-global/answers.html"><strong aria-hidden="true">2.5.1.</strong> Answers</a></li></ol></li><li class="chapter-item expanded "><a href="exercises/subobject-bounds/index.html"><strong aria-hidden="true">2.6.</strong> Explore subobject bounds</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="exercises/subobject-bounds/answers.html"><strong aria-hidden="true">2.6.1.</strong> Answers</a></li></ol></li><li class="chapter-item expanded "><a href="exercises/control-flow-pointer/index.html"><strong aria-hidden="true">2.7.</strong> Corrupt a control-flow pointer using a subobject buffer overflow</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="exercises/control-flow-pointer/answers.html"><strong aria-hidden="true">2.7.1.</strong> Answers</a></li></ol></li><li class="chapter-item expanded "><a href="exercises/buffer-overflow-heap/index.html"><strong aria-hidden="true">2.8.</strong> Exercise heap overflows</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="exercises/buffer-overflow-heap/answers.html"><strong aria-hidden="true">2.8.1.</strong> Answers</a></li></ol></li><li class="chapter-item expanded "><a href="exercises/type-confusion/index.html"><strong aria-hidden="true">2.9.</strong> Exercise integer-pointer type confusion bug</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="exercises/type-confusion/answers.html"><strong aria-hidden="true">2.9.1.</strong> Answers</a></li></ol></li><li class="chapter-item expanded "><a href="exercises/pointer-injection/index.html"><strong aria-hidden="true">2.10.</strong> Demonstrate pointer injection</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="exercises/pointer-injection/answers.html"><strong aria-hidden="true">2.10.1.</strong> Answers</a></li></ol></li><li class="chapter-item expanded "><a href="exercises/adapt-c/index.html"><strong aria-hidden="true">2.11.</strong> Adapt a C Program to CHERI C</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="exercises/adapt-c/answers.html"><strong aria-hidden="true">2.11.1.</strong> Answers</a></li></ol></li><li class="chapter-item expanded "><a href="exercises/cheriabi/index.html"><strong aria-hidden="true">2.12.</strong> CheriABI Showcase</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="exercises/cheriabi/answers.html"><strong aria-hidden="true">2.12.1.</strong> Answers</a></li></ol></li><li class="chapter-item expanded "><a href="exercises/cheri-allocator/index.html"><strong aria-hidden="true">2.13.</strong> Extending Heap Allocators for CHERI</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="exercises/cheri-allocator/answers.html"><strong aria-hidden="true">2.13.1.</strong> Answers</a></li></ol></li><li class="chapter-item expanded "><a href="exercises/pointer-revocation/index.html"><strong aria-hidden="true">2.14.</strong> Demonstrate pointer revocation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="exercises/pointer-revocation/answers.html"><strong aria-hidden="true">2.14.1.</strong> Answers</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="missions/index.html"><strong aria-hidden="true">3.</strong> Focused Adversarial Missions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="missions/buffer-overflow-control-flow/index.html"><strong aria-hidden="true">3.1.</strong> Exploiting a buffer overflow to manipulate control flow</a></li><li class="chapter-item expanded "><a href="missions/uninitialized-stack-frame-control-flow/index.html"><strong aria-hidden="true">3.2.</strong> Exploiting an uninitialized stack frame to manipulate control flow</a></li><li class="chapter-item expanded "><a href="missions/use-after-free-control-flow/index.html"><strong aria-hidden="true">3.3.</strong> Exploiting heap use-after-free to manipulate control flow</a></li><li class="chapter-item expanded "><a href="missions/kernel-FreeBSD-SA-09-06.ktimer/index.html"><strong aria-hidden="true">3.4.</strong> Exploiting kernel system-call vulnerability to manipulate control flow</a></li><li class="chapter-item expanded "><a href="missions/kernel-FreeBSD-SA-18-13.nfs/index.html"><strong aria-hidden="true">3.5.</strong> Exploiting kernel NFS-server vulnerability to manipulate control flow</a></li></ol></li><li class="chapter-item expanded "><a href="appendix/index.html"><strong aria-hidden="true">4.</strong> Appendix</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Adversarial CHERI Exercises and Missions</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        <a href="https://github.com/CTSRD-CHERI/cheri-exercises" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#adversarial-cheri-exercises-and-missions" id="adversarial-cheri-exercises-and-missions">Adversarial CHERI Exercises and Missions</a></h1>
<p>Robert N. M. Watson (University of Cambridge), Brooks Davis (SRI
International), Wes Filardo (Microsoft Research), Jessica Clarke (University of
Cambridge) and John Baldwin (Ararat River Consulting).</p>
<p>This repository contains a series of skills development and adversarial
exercises for <a href="http://cheri-cpu.org">CHERI</a>, specifically aimed at the
CHERI-RISC-V implementation.</p>
<h2><a class="header" href="#acknowledgements" id="acknowledgements">Acknowledgements</a></h2>
<p>The authors gratefully acknowledge Reuben Broadfoot, Lawrence Esswood, Brett
Gutstein, Joe Kiniry, Alex Richardson, Austin Roach, and Daniel Zimmerman for
their feedback and support in developing these exercises.</p>
<p><em>Some portions of this document remain a work-in-progress.  Feedback and
contributions are welcomed.  Please see our <a href="https://github.com/CTSRD-CHERI/cheri-exercises">GitHub
Repository</a> for the source
code and an issue tracker.</em></p>
<h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<p>This set of exercises and adversarial missions is intended to:</p>
<ul>
<li>Build a baseline skillset with RISC-V and CHERI-RISC-V, as well as awareness
of some of the dynamics of CHERI-enabled software, through skills development
exercises.</li>
<li>Develop adversarial experience with CHERI-RISC-V performing basic
investigation around gradations of CHERI feature deployment through focused
adversarial missions.</li>
</ul>
<p>These activities supplement existing experience
with reverse engineering and exploitation on conventional architectures
and software stacks.</p>
<h2><a class="header" href="#platform" id="platform">Platform</a></h2>
<p>These exercises are designed to be run on the CheriBSD operating system in its
pure-capability CheriABI process environment.
They can be run on various instantiations of CHERI-RISC-V, including on QEMU
and on FPGA implementations.
QEMU-CHERI is a convenient instruction-set-level emulator, and is usaully the
best starting point for most users (even those intending to eventually run on
hardware).
You can use our <a href="https://github.com/CTSRD-CHERI/cheribuild">cheribuild</a> tool
to build the CHERI-RISC-V SDK, CheriBSD, and QEMU on macOS, FreeBSD, and Linux.</p>
<h2><a class="header" href="#skills-development-exercises" id="skills-development-exercises">Skills development exercises</a></h2>
<p><strong>Skills development exercises</strong> are intended to take 1-2 hours each,
and ask you to build and perform minor modifications to simple
RISC-V and CHERI-RISC-V C/C++ programs. These exercises
facilitate building skills such as compiling, executing,
and debugging RISC-V and CHERI-RISC-V programs, as well as to build basic
understanding of CHERI C/C++ properties. We highlight some key edge
cases in CHERI, including the effects of bounds imprecision, subobject
bounds, weaker temporal safety, and C type confusion.</p>
<p>These exercises take for granted a strong existing understanding of:</p>
<ul>
<li>The C/C++ languages</li>
<li>UNIX program compilation, execution, and debugging</li>
<li>RISC ISAs and binary structures/reverse engineering (e.g., on MIPS or ARMv8)</li>
</ul>
<h2><a class="header" href="#focused-adversarial-missions" id="focused-adversarial-missions">Focused adversarial missions</a></h2>
<p><strong>Focused adversarial missions</strong> are intended to take
1-3 days, and ask you to exploit, first on RISC-V, and
then on CHERI-RISC-V, documented vulnerabilities in simple &quot;potted&quot;
C/C++-language programs provided by the CHERI-RISC-V team. These missions
engage you more specifically in RISC-V exploitation, and CHERI's
security objectives and mechanisms.</p>
<p><strong>These take for granted good existing experience with
memory-safety-related attack techniques, such as buffer overflows,
integer-pointer type confusion, Return-Oriented Programming (ROP), and
Jump-Oriented Programming (JOP).</strong></p>
<p>Successful exploitation of RISC-V variants depends only upon
widely published understanding and techniques (e.g., buffer overflows
combined with ROP). For those familiar with conventional low-level
attack techniques, this will also act as a warm-up exercise on the
baseline RISC-V architecture and expand experience with RISC-V reverse
engineering and exploitation.</p>
<p>The CHERI-RISC-V team has confirmed exploitability for the RISC-V binary
in advance.  We strongly recommend exploiting the RISC-V version of the code
first, as a starting point for understanding potential CHERI-RISC-V
exploitability.</p>
<h1><a class="header" href="#background-reading" id="background-reading">Background reading</a></h1>
<p>To perform these exercises most effectively, we recommend first building a
working knowledge of CHERI.  The most critical references will be the
<em>Introduction to CHERI</em> and <em>CHERI C/C++ Programming Guide</em>, but there is a
broad variety of other reference material available regarding CHERI:</p>
<ul>
<li><a href="https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-941.pdf">An Introduction to CHERI</a> - An overview of the CHERI architecture, security model, and programming models.</li>
<li><a href="https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-947.pdf">CHERI C/C++ Programming Guide</a> - This use of CHERI capabilities to represent C/C++ pointers requires modest changes to the way C and C++ are used. This document describes those changes.</li>
<li><a href="https://www.cl.cam.ac.uk/research/security/ctsrd/pdfs/201904-asplos-cheriabi.pdf">CheriABI: Enforcing Valid Pointer Provenance and Minimizing Pointer Privilege in the POSIX C Run-time Environment</a> - This paper describes the CheriABI pure-capability process environment these exercises are expected to use. An extended <a href="https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-932.pdf">technical report</a> is also available.</li>
<li><a href="https://www.cl.cam.ac.uk/research/security/ctsrd/pdfs/2020oakland-cornucopia.pdf">Cornucopia: Temporal Safety for CHERI Heaps</a> - The temporal-safety exercises require the use of Cornucopia's quarantine and revocation infrastructure.</li>
<li><a href="https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-951.pdf">Capability Hardware Enhanced RISC Instructions:
CHERI Instruction-Set Architecture (Version 8)</a> - Instruction reference and design discussion.</li>
<li><a href="https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-949.pdf">Complete spatial safety for C and C++ using CHERI capabilities</a> - This PhD dissertation provides an extensive overview of the CHERI-MIPS linking model (also relevant to the current CHERI-RISC-V model), an implementation of opportunistic subobject bounds, and general C/C++ compatibility issues.</li>
</ul>
<h1><a class="header" href="#cross-compilation-and-execution" id="cross-compilation-and-execution">Cross compilation and execution</a></h1>
<h2><a class="header" href="#obtaining-a-compiler-and-sysroot" id="obtaining-a-compiler-and-sysroot">Obtaining a compiler and sysroot</a></h2>
<p>If you already have a compiler and sysroot (e.g. you have a docker image with pre-compiled versions), you will need to know the path to <code>clang</code> and the path to your sysroot.  You can then proceed to <a href="introduction/cross-compilation-execution.html#compiler-command-line"><strong>Compiler command line</strong></a>.</p>
<h3><a class="header" href="#building-a-cross-build-environment-with-cheribuild" id="building-a-cross-build-environment-with-cheribuild">Building a cross build environment with cheribuild</a></h3>
<p>First, clone the cheribuild repo:</p>
<pre><code>git clone https://github.com/CTSRD-CHERI/cheribuild.git
</code></pre>
<p>The <a href="https://github.com/CTSRD-CHERI/cheribuild/blob/master/README.md">README.md</a> file contains considerable information, but to get started, you'll need to bootstrap an LLVM compiler and a CheriBSD build and sysroot.  The easiest path to doing this is:</p>
<pre><code>cheribuild.py cheribsd-riscv64-purecap -d
</code></pre>
<p>This will churn away, prompting occasionally as it bootstraps assorted dependencies.  On a fast machine this will take several hours.</p>
<!-- XXX: Should we advocate `-f` here? -->
<p>Upon completion, you will find a usable Clang compiler in <code>~/cheri/output/sdk/bin/clang</code> and a sysroot in <code>~/cheri/output/rootfs-riscv64-purecap</code> (unless you have altered <code>cheribuild</code>'s default paths).</p>
<h2><a class="header" href="#compiler-command-line" id="compiler-command-line">Compiler command line</a></h2>
<p>In this set of exercises we cross compile in two basic modes.
Conventional RISC-V ABI and the CheriABI pure-capability ABI.</p>
<h3><a class="header" href="#common-elements" id="common-elements">Common elements</a></h3>
<p>All command lines will share some comment elements to target 64-bit RISC-V, select the linker, and indicate where to find the sysroot.</p>
<p>Some conventions:</p>
<ul>
<li><code>$SYSROOT</code> is the path to your sysroot.</li>
<li><code>$CLANG</code> is the path to your compiler.</li>
<li>All compiler commands begin with <code>$CLANG -target riscv64-unknown-freebsd --sysroot=&quot;$SYSROOT&quot; -fuse-ld=lld -mno-relax</code></li>
<li>As a rule, you will want to add <code>-g</code> to the command line to compile with debug symbols.</li>
<li>You will generally want to compile with <code>-O2</code> as the unoptimized assembly is verbose and hard to follow.</li>
<li>We strongly recommend you compile with warnings on including <code>-Wall</code> and <code>-Wcheri</code>.</li>
</ul>
<h3><a class="header" href="#risc-v" id="risc-v">RISC-V</a></h3>
<p>Two additional arguments are required to specify the supported architectural features and ABI.  For conventional RISC-V, those are: <code> -march=rv64gc -mabi=lp64d</code>.
Putting it all together:</p>
<pre><code>$CLANG -g -O2 -target riscv64-unknown-freebsd --sysroot=&quot;$SYSROOT&quot; -fuse-ld=lld -mno-relax -march=rv64gc -mabi=lp64d -Wall -Wcheri
</code></pre>
<h3><a class="header" href="#cheriabi" id="cheriabi">CheriABI</a></h3>
<p>For CheriABI, the architecture and ABI flags are:
<code>-march=rv64gcxcheri -mabi=l64pc128d</code>.
Putting it all together:</p>
<pre><code>$CLANG -g -O2 -target riscv64-unknown-freebsd --sysroot=&quot;$SYSROOT&quot; -fuse-ld=lld -mno-relax -march=rv64gcxcheri -mabi=l64pc128d -Wall -Wcheri
</code></pre>
<h2><a class="header" href="#executing-binaries" id="executing-binaries">Executing binaries</a></h2>
<p>CheriBSD supports running RISC-V and CHERI-RISC-V side-by-side on the same instance, so provided the instance has all features available for the exercise or mission in question, you should be able to complete it on a single CheriBSD instance.</p>
<p>CheriBSD's <code>file(1)</code> has been extended to distinguish RISC-V binaries from CHERI-RISC-V (CheriABI) binaries. For example, on a CheriBSD instance:</p>
<pre><code># file riscv-binary
riscv-binary: ELF 64-bit LSB shared object, UCB RISC-V, RVC, double-float ABI, version 1 (SYSV), dynamically linked, interpreter /libexec/ld-elf.so.1, for FreeBSD 13.0 (1300097), FreeBSD-style, with debug_info, not stripped
# file cheri-binary
cheri-binary: ELF 64-bit LSB shared object, UCB RISC-V, RVC, double-float ABI, capability mode, CheriABI, version 1 (SYSV), dynamically linked, interpreter /libexec/ld-elf.so.1, for FreeBSD 13.0 (1300097), FreeBSD-style, with debug_info, not stripped
</code></pre>
<p>CHERI-LLVM and the elfutils in CheriBSD also recognise the relevant ELF flags. For example, CHERI-LLVM on the host used for cross-compiling will report:</p>
<pre><code># llvm-readelf -h riscv-binary | grep Flags
  Flags:                             0x5, RVC, double-float ABI
# llvm-readelf -h cheri-binary | grep Flags
  Flags:                             0x30005, RVC, double-float ABI, cheriabi, capability mode
</code></pre>
<p>and elfutils on a CheriBSD instance will report:</p>
<pre><code># readelf -h riscv-binary | grep Flags
  Flags:                             0x5, double-float ABI, RVC
# readelf -h cheri-binary | grep Flags
  Flags:                             0x30005, double-float ABI, RVC, cheriabi, capmode
</code></pre>
<h1><a class="header" href="#helper-script" id="helper-script">Helper script</a></h1>
<p>Because the command line required to compile exercises is quite unwieldy, we've created a wrapper script to help out, shown below.  If you've checked out this repository it's present in <code>tools/ccc</code>.  The usage is:</p>
<pre><code>ccc &lt;arch&gt; [...]

Supported architectures:
	aarch64         - conventional AArch64
	morello-hybrid  - AArch64 Morello supporting CHERI
	morello-purecap - AArch64 Morello pure-capability
	riscv64         - conventional RISC-V 64-bit
	riscv64-hybrid  - RISC-V 64-bit supporting CHERI
	riscv64-purecap - RISC-V 64-bit pure-capability
</code></pre>
<p>and it can be used in place of your compiler.</p>
<p>For the exercises in this book you will use the <code>riscv64</code> and <code>riscv64-purecap</code> architectures.  The <code>riscv64-hybrid</code> architecture instantiates appropriately annotated pointers as capabilities leaving the rest as conventional integer addresses, but is not used here.</p>
<p>If you have built a compiler and sysroot using <code>cheribuild</code> in the default location (<code>~/cheri</code>) then it should work out of the box.  If you've configured a different location you can set the <code>CHERIBUILD_SDK</code> environment variable to point to to the location of your SDK.  Alternatively, you can set the <code>CLANG</code> and <code>SYSROOT</code> variables to point to the respective locations.</p>
<pre><code class="language-sh">#!/bin/sh
#
# ccc - Cross compilation script
set -e
set -u

name=$(basename &quot;$0&quot;)

VERBOSE=${VERBOSE:-0}
QUIET=${QUIET:-0}

usage()
{
	cat &lt;&lt;EOF
$name &lt;arch&gt; [...]

Supported architectures:
	aarch64         - conventional AArch64
	morello-hybrid  - AArch64 Morello supporting CHERI
	morello-purecap - AArch64 Morello pure-capability
	riscv64         - conventional RISC-V 64-bit
	riscv64-hybrid  - RISC-V 64-bit supporting CHERI
	riscv64-purecap - RISC-V 64-bit pure-capability
EOF
	exit 1
}

err()
{
	ret=$1
	shift
	echo &gt;&amp;2 &quot;$@&quot;
	exit &quot;$ret&quot;
}

warn()
{
	echo &gt;&amp;2 &quot;$@&quot;
}

debug()
{
	if [ &quot;$VERBOSE&quot; -ne 0 ]; then
		echo &gt;&amp;2 &quot;$@&quot;
	fi
}

info()
{
	if [ &quot;$QUIET&quot; -eq 0 ]; then
		echo &gt;&amp;2 &quot;$@&quot;
	fi
}

run()
{
	debug	# add space before normal multiline output
	info &quot;Running:&quot; &quot;$@&quot;
	&quot;$@&quot;
}

if [ $# -eq 0 ]; then
	usage
fi

arch=$1
shift

cheri_arch_basename=${arch%%-*}
cheri_sdk_name=sdk
case $arch in
aarch64)
	cheri_arch_basename=morello
	cheri_sdk_name=morello-sdk
	arch_flags=&quot;-target aarch64-unknown-freebsd -march=morello+noa64c&quot;
	;;
morello-hybrid)
	cheri_sdk_name=morello-sdk
	arch_flags=&quot;-target aarch64-unknown-freebsd -march=morello+a64c&quot;
	;;
morello-purecap)
	cheri_sdk_name=morello-sdk
	arch_flags=&quot;-target aarch64-unknown-freebsd -march=morello+c64 -mabi=purecap -femulated-tls&quot;
	;;
riscv64)
	arch_flags=&quot;-target riscv64-unknown-freebsd -march=rv64gc -mabi=lp64d -mno-relax&quot;
	;;
riscv64-hybrid)
	arch_flags=&quot;-target riscv64-unknown-freebsd -march=rv64gcxcheri -mabi=lp64d -mno-relax&quot;
	;;
riscv64-purecap)
	arch_flags=&quot;-target riscv64-unknown-freebsd -march=rv64gcxcheri -mabi=l64pc128d -mno-relax&quot;
	;;
*)
	err 1 &quot;Unsupported architecture '$arch'&quot;
	;;
esac

CHERIBUILD_SDK=${CHERIBUILD_SDK:-${HOME}/cheri/output/${cheri_sdk_name}}
CLANG=${CLANG:-${CHERIBUILD_SDK}/bin/clang}

case $name in
*clang|*cc)	prog=&quot;${CLANG}&quot; ;;
*clang++|*c++)	prog=&quot;${CLANG}++&quot; ;;
*)	err 1 &quot;Unsupported program name '$name'&quot; ;;
esac
if [ ! -x &quot;$prog&quot; ]; then
	err 1 &quot;Target program '$prog' not found. Set CLANG or CHERIBUILD_SDK.&quot;
fi
debug &quot;prog: $prog&quot;

SYSROOT=${SYSROOT:-${CHERIBUILD_SDK}/sysroot-${cheri_arch_basename}-purecap}
if [ ! -d &quot;$SYSROOT&quot; ]; then
	err 1 &quot;Sysroot '$SYSROOT' does not exist. Set SYSROOT or CHERIBUILD_SDK.&quot;
fi
debug &quot;sysroot: $SYSROOT&quot;

debug &quot;arch_flags: $arch_flags&quot;

debug_flags=&quot;-g&quot;
debug &quot;debug_flags: $debug_flags&quot;

opt_flags=&quot;-O2&quot;
debug &quot;opt_flags: $opt_flags&quot;

sysroot_flags=&quot;--sysroot='$SYSROOT'&quot;
debug &quot;sysroot_flags: $sysroot_flags&quot;

linker_flags=&quot;-fuse-ld=lld&quot;
debug &quot;linker_flags: $linker_flags&quot;

diag_flags=&quot;-Wall -Wcheri&quot;
debug &quot;diag_flags: $diag_flags&quot;

all_flags=&quot;$arch_flags $sysroot_flags $debug_flags $opt_flags $linker_flags $diag_flags&quot;

all_flags_rev=
# shellcheck disable=SC2086 # intentional
eval 'for flag in '$all_flags'; do
	all_flags_rev=&quot;'&quot;'&quot;'$flag'&quot;'&quot;'${all_flags_rev:+ $all_flags_rev}&quot;
done'

# shellcheck disable=SC2086 # intentional
eval 'for flag in '$all_flags_rev'; do
	set -- &quot;$flag&quot; &quot;$@&quot;
done'

run &quot;$prog&quot; &quot;$@&quot;
</code></pre>
<p>If you were provided a docker image along with these instructions (e.g. as part of a training exercise or bug-bounty), it should be configured such that <code>ccc</code> works without setting environment variables.</p>
<p>Although not used by these exercises, the tool will instead function as a C++ compiler if invoked via the name <code>cc++</code>, and a <code>tools/cc++</code> symlink exists to facilitate this.</p>
<h1><a class="header" href="#skills-development-exercises-1" id="skills-development-exercises-1">Skills Development Exercises</a></h1>
<p>For a researcher to contribute effectively to CHERI-RISC-V evaluation,
they will need a baseline skill-set that includes significant existing
experience with:</p>
<ul>
<li>C/C++-language memory-safety vulnerabilities</li>
<li>Binary reverse engineering for at least one ISA, such as x86, MIPS, ARMv7, or ARMv8</li>
<li>Low-level aspects of program representation, such as ELF, GOTs, and PLTs, as well as mechanisms such as dynamic linking and system-call handling</li>
<li>Attack techniques against program control flow and underlying data structures including ROP and JOP</li>
</ul>
<p>However, we expect that researchers may need to build specific
additional skills with respect to the specifics of RISC-V machine code,
assembly, language, and linkage, as well as knowledge about the CHERI
C/C++ protection model and CHERI-RISC-V extensions to RISC-V. These
exercises are intended to assist in these latter two areas, faulting
in missing knowledge and experience while building on existing skills
gained on other architectures (such as x86-64 and ARMv8). Participants
successfully completing these exercises will be able to:</p>
<ul>
<li>Compile, run, disassemble, and debug RISC-V compiled C/C++ programs</li>
<li>Compile, run, disassemble, and debug CHERI-RISC-V compiled C/C++ programs</li>
<li>Use specific debugging tools such as GDB and llvm-objdump with RISC-V and CHERI-RISC-V programs</li>
<li>Understand some of the implications of CHERI protections for specific aspects of C/C++ and process execution</li>
</ul>
<p>Each exercise includes:</p>
<ul>
<li>Sample source code and build instructions</li>
<li>A short document describing what the program does and the objectives</li>
<li>Where there are exercise questions, sample answers</li>
</ul>
<h1><a class="header" href="#compile-and-run-risc-v-and-cheri-risc-v-programs" id="compile-and-run-risc-v-and-cheri-risc-v-programs">Compile and run RISC-V and CHERI-RISC-V programs</a></h1>
<p>This exercise steps you through getting up and running with code compilation
and execution for RISC-V and CHERI-RISC-V programs.</p>
<p>The first test program is written in conventional C, and can be compiled
to RISC-V or CHERI-RISC-V targets:</p>
<ol>
<li>Compile <code>print-pointer.c</code> with a RISC-V target and a binary name of
<code>print-pointer-riscv</code>.</li>
</ol>
<p><strong>print-pointer.c:</strong></p>
<pre><code class="language-C">/*
 * SPDX-License-Identifier: BSD-2-Clause-DARPA-SSITH-ECATS-HR0011-18-C-0016
 * Copyright (c) 2020 SRI International
 */
#include &lt;stdio.h&gt;

int
main(void)
{
	printf(&quot;size of pointer: %zu\n&quot;, sizeof(void *));
	/* XXX: ideally we'd use ptraddr_t below */
	printf(&quot;size of address: %zu\n&quot;, sizeof(size_t));

	return (0);
}
</code></pre>
<ol start="2">
<li>Run the binary.</li>
<li>Compile <code>print-pointer.c</code> with a CHERI-RISC-V target and a binary name
of <code>print-pointer-cheri</code>.</li>
<li>Run the binary: it should print a pointer size of <code>16</code> and address size
of <code>8</code>.</li>
</ol>
<p>The second test program is written in CHERI C:</p>
<ol start="5">
<li>Compile <code>print-capability.c</code> with a CHERI-RISC-V target and a binary name
of <code>print-capability</code>.</li>
</ol>
<pre><code class="language-C">/*
 * SPDX-License-Identifier: BSD-2-Clause-DARPA-SSITH-ECATS-HR0011-18-C-0016
 * Copyright (c) 2020 SRI International
 */
#include &lt;stdio.h&gt;
#include &lt;cheriintrin.h&gt;

int
main(void)
{
	int i;
	char *c;
	void *cap_to_int = &amp;i;
	void *cap_to_cap = &amp;c;

	printf(&quot;cap to int length: %lu\n&quot;, cheri_length_get(cap_to_int));
	printf(&quot;cap to cap length: %lu\n&quot;, cheri_length_get(cap_to_cap));

	return (0);
}
</code></pre>
<ol start="6">
<li>Run the binary: note how the length of the capability depends on the size of
the type it points to.</li>
</ol>
<h1><a class="header" href="#answers---compile-and-run-risc-v-and-cheri-risc-v-programs" id="answers---compile-and-run-risc-v-and-cheri-risc-v-programs">Answers - Compile and run RISC-V and CHERI-RISC-V programs</a></h1>
<p>This exercise explores the difference in size between addresses and
pointers, drawing attention to the pointer-focused nature of CHERI memory
protection.</p>
<ol start="2">
<li>Expected output:</li>
</ol>
<pre><code># ./print-pointer-riscv
size of pointer: 8
size of address: 8
</code></pre>
<ol start="4">
<li>Expected output:</li>
</ol>
<pre><code># ./print-pointer-cheri
size of pointer: 16
size of address: 8
</code></pre>
<ol start="6">
<li>Expected output:</li>
</ol>
<pre><code># ./print-capability
cap to int length: 4
cap to cap length: 16
</code></pre>
<h1><a class="header" href="#disassemble-and-debug-risc-v-and-cheri-risc-v-programs" id="disassemble-and-debug-risc-v-and-cheri-risc-v-programs">Disassemble and debug RISC-V and CHERI-RISC-V programs</a></h1>
<p>This exercise steps you through disassembling and debugging
RISC-V and CHERI-RISC-V programs. It draws attention to differences in
program structure and code generation, particularly relating to control
flow, between the two compilation targets.</p>
<p>First, use <code>llvm-objdump</code> on the host (which you can find at
<code>~/cheri/output/sdk/bin/llvm-objdump</code>, unless you have altered <code>cheribuild</code>'s
default paths) to disassemble and explore the two binaries from the previous
exercise:</p>
<ol>
<li>Using <code>llvm-objdump -dS</code>, disassemble the <code>print-pointer-riscv</code> and
<code>print-pointer-cheri</code> binaries.</li>
<li>What jump instruction is used to call <code>printf()</code> in <code>print-pointer-riscv</code>?
Where does the target address for that jump originate?</li>
<li>What jump instruction is used to call <code>printf()</code> in <code>print-pointer-cheri</code>?
Where does the target capability for that jump originate?
(Hint, you may find it helpful to add the <code>-s</code> flag to your
<code>llvm-objdump</code> command to see all sections.)</li>
</ol>
<p>Next use GDB to explore binary execution for RISC-V:</p>
<ol start="4">
<li>Run <code>print-pointer-riscv</code> under GDB, setting a breakpoint at the start
of <code>printf()</code>.
<em>Note:</em> GDB can't find the run-time linker of binaries of the
non-default ABI on its own so you need to invoke
<code>set program-interpreter /libexec/ld-elf64.so.1</code>
before running the program.<!-- This might want to go in the introductory material -->
</li>
<li>Run the program and at the breakpoint, print out the value of the
string pointer argument.</li>
<li>Use <code>info proc mappings</code> in GDB to print out the layout of the
process address space.</li>
<li>Print out the program counter (<code>info reg pc</code>).
What memory mapping is it derived from?</li>
</ol>
<p>And for CHERI-RISC-V:</p>
<ol start="8">
<li>Run <code>print-pointer-cheri</code> under GDB, setting a breakpoint at the start
of <code>printf()</code>.</li>
<li>Print out the value of the string pointer argument.</li>
<li>Use <code>info proc mappings</code> (in GDB) to print out the layout of the
process address space.</li>
<li>Print out the program counter (<code>info reg pcc</code>).
What memory mapping is it derived from?
Where do its bounds appear to originate from?</li>
<li>Print out the register file using <code>info registers</code>.
What mappings do the capabilities in the register file point to?
Notice that some capabilities are labeled with <code>(sentry)</code> (or <code>(sealed)</code> in
the case of older versions of GDB which do not distinguish sentries from
other sealed capabilities).
Sentry capabilities are sealed (cannot be modified or used to load or
store), but can be used as a jump target (where they are unsealed and
installed in <code>pcc</code>).
What implications does this have for attackers?</li>
</ol>
<h1><a class="header" href="#answers---disassemble-and-debug-risc-v-and-cheri-risc-v-programs" id="answers---disassemble-and-debug-risc-v-and-cheri-risc-v-programs">Answers - Disassemble and debug RISC-V and CHERI-RISC-V programs</a></h1>
<ol start="2">
<li><code>jalr</code>. The target address is a pc-relative address in the <code>.plt</code>
section addressed by a sequence like:</li>
</ol>
<pre><code>   1182a: 97 00 00 00   auipc   ra, 0
   1182e: e7 80 60 0e   jalr    230(ra)
</code></pre>
<ol start="3">
<li><code>cjalr</code>. The target capability is loaded from the <code>.captable</code> section
by a sequence like:</li>
</ol>
<pre><code>    1b2e: 17 24 00 00   auipcc  cs0, 2
    1b32: 0f 24 24 27   clc     cs0, 626(cs0)
    1b36: db 00 c4 fe   cjalr   cs0
</code></pre>
<ol start="4">
<li>Example session:</li>
</ol>
<pre><code>(gdb) b printf
Breakpoint 1 at 0x11914
</code></pre>
<ol start="5">
<li>Example session:</li>
</ol>
<pre><code>(gdb) r
Starting program: /root/print-pointer-riscv 

Breakpoint 1, printf (fmt=&lt;optimized out&gt;)
    at /Volumes/CheriBSD/cheribsd/lib/libc/stdio/printf.c:56
56      /Volumes/CheriBSD/cheribsd/lib/libc/stdio/printf.c: No such file or directory.
(gdb) info reg a0
a0             0x1054f  66895
</code></pre>
<ol start="6">
<li>Example session:</li>
</ol>
<pre><code>(gdb) info proc mappings
process 764
Mapped address spaces:

          Start Addr           End Addr       Size     Offset   Flags   File
             0x10000            0x11000     0x1000        0x0  r-- CN-- /root/print-pointer-riscv
             0x11000            0x12000     0x1000        0x0  r-x C--- /root/print-pointer-riscv
             0x12000            0x13000     0x1000        0x0  r-- C--- /root/print-pointer-riscv
             0x13000            0x14000     0x1000        0x0  rw- ---- 
          0x40013000         0x40018000     0x5000        0x0  r-- CN-- /libexec/ld-elf64.so.1
          0x40018000         0x4002a000    0x12000     0x4000  r-x C--- /libexec/ld-elf64.so.1
          0x4002a000         0x4002b000     0x1000    0x15000  rw- C--- /libexec/ld-elf64.so.1
          0x4002b000         0x4004e000    0x23000        0x0  rw- ---- 
          0x4004f000         0x400c2000    0x73000        0x0  r-- CN-- /usr/lib64/libc.so.7
          0x400c2000         0x401de000   0x11c000    0x72000  r-x C--- /usr/lib64/libc.so.7
          0x401de000         0x401e8000     0xa000   0x18d000  r-- C--- /usr/lib64/libc.so.7
          0x401e8000         0x401ef000     0x7000   0x196000  rw- C--- /usr/lib64/libc.so.7
          0x401ef000         0x40419000   0x22a000        0x0  rw- ---- 
          0x40600000         0x40e00000   0x800000        0x0  rw- ---- 
        0x3f3ef00000       0x3f7eee0000 0x3ffe0000        0x0  --- ---- 
        0x3f7eee0000       0x3f7ef00000    0x20000        0x0  rw- ---D 
        0x3f7efff000       0x3f7f000000     0x1000        0x0  r-x ---- 
</code></pre>
<ol start="7">
<li>Example session:</li>
</ol>
<pre><code>(gdb) info reg pc 
pc             0x401bf640       1075574336
</code></pre>
<p>In this example, the pointer resides in:</p>
<pre><code>0x400c2000         0x401de000   0x11c000    0x72000  r-x C--- /usr/lib64/libc.so.7
</code></pre>
<ol start="8">
<li>Example session:</li>
</ol>
<pre><code>(gdb) b printf
Function &quot;printf&quot; not defined.
Make breakpoint pending on future shared library load? (y or [n]) y
Breakpoint 1 (printf) pending.
</code></pre>
<ol start="9">
<li>Example session:</li>
</ol>
<pre><code>(gdb) r
Starting program: /root/print-pointer-cheri 

Breakpoint 1, printf (
    fmt=0x1004ef [rR,0x1004ef-0x100505] &quot;size of pointer: %zu\n&quot;)
    at /Volumes/CheriBSD/cheribsd/lib/libc/stdio/printf.c:54
54      /Volumes/CheriBSD/cheribsd/lib/libc/stdio/printf.c: No such file or directory.
(gdb) p fmt
$1 = 0x1004ef [rR,0x1004ef-0x100505] &quot;size of pointer: %zu\n&quot;
</code></pre>
<ol start="10">
<li>Example session:</li>
</ol>
<pre><code>(gdb) info proc mappings
process 767
Mapped address spaces:

          Start Addr           End Addr       Size     Offset   Flags   File
            0x100000           0x101000     0x1000        0x0  r-- CN-- /root/print-pointer-cheri
            0x101000           0x102000     0x1000        0x0  r-x CN-- /root/print-pointer-cheri
            0x102000           0x103000     0x1000        0x0  r-- C--- /root/print-pointer-cheri
            0x103000           0x104000     0x1000        0x0  rw- ---- 
          0x40103000         0x4010a000     0x7000        0x0  rw- ---- 
          0x4010a000         0x4010c000     0x2000        0x0  --- CN-- 
          0x4010d000         0x40193000    0x86000        0x0  r-- CN-- /lib/libc.so.7
          0x40193000         0x4028c000    0xf9000    0x85000  r-x C--- /lib/libc.so.7
          0x4028c000         0x40293000     0x7000   0x17d000  r-- C--- /lib/libc.so.7
          0x40293000         0x402ac000    0x19000   0x183000  rw- C--- /lib/libc.so.7
          0x402ac000         0x402c9000    0x1d000        0x0  rw- ---- 
          0x402c9000         0x402f1000    0x28000        0x0  rw- ---- 
          0x41000000         0x4100b000     0xb000        0x0  r-- CN-- /libexec/ld-elf.so.1
          0x4100b000         0x4102a000    0x1f000     0xa000  r-x C--- /libexec/ld-elf.so.1
          0x4102a000         0x4102b000     0x1000    0x28000  rw- C--- /libexec/ld-elf.so.1
          0x4102b000         0x4102e000     0x3000    0x28000  rw- C--- /libexec/ld-elf.so.1
          0x4102e000         0x41030000     0x2000        0x0  rw- ---- 
        0x3f3ef00000       0x3f7ece0000 0x3fde0000        0x0  --- ---- 
        0x3f7ece0000       0x3f7eee0000   0x200000        0x0  rw- ---D 
        0x3f7eee0000       0x3f7ef00000    0x20000        0x0  rw- ---D 
        0x3f7efff000       0x3f7f000000     0x1000        0x0  r-x ---- 
        0x3f7f000000       0x4000000000 0x81000000        0x0  rw- ---- 
</code></pre>
<ol start="11">
<li>Example session:</li>
</ol>
<pre><code>(gdb) info reg pcc
pcc            0xf11720000325d0d4000000004026e9e6       0x4026e9e6 &lt;printf+14&gt; [rxR,0x4010d000-0x402c9000]
</code></pre>
<p>The capability points at:</p>
<pre><code>          0x40193000         0x4028c000    0xf9000    0x85000 r-x C--- /lib/libc.so.7
</code></pre>
<ol start="12">
<li>Left as an exercise to the reader.</li>
</ol>
<h1><a class="header" href="#demonstrate-cheri-tag-protection" id="demonstrate-cheri-tag-protection">Demonstrate CHERI Tag Protection</a></h1>
<p>This exercise demonstrates CHERI's <em>capability provenance tags</em>, in particular
by showing that capabilities and their constituent bytes are subtly different
things!</p>
<ol>
<li>
<p>Compile <code>corrupt-pointer.c</code> for the baseline architecture to the binary
<code>corrupt-pointer-baseline</code> and for the CHERI-aware architecture to
<code>corrupt-pointer-cheri</code>.</p>
</li>
<li>
<p>Run both programs and observe the output.</p>
</li>
<li>
<p>Use <code>gdb</code> to inspect the <code>SIGPROT</code> thrown to the CHERI program.</p>
<p>Print out the pseudoregister <code>$_siginfo</code>.  <code>si_signo</code> <code>34</code> is <code>SIGPROT</code>, a
new signal introduced for conveying CHERI traps to user programs.  The
<code>si_code</code> values for <code>SIGPROT</code> signals are defined as the various
<code>PROT_CHERI_*</code> values in <code>&lt;sys/signal.h&gt;</code> (which can be found in
<code>/usr/include</code> in a CheriBSD system).</p>
</li>
<li>
<p>Examine the disassembly of the construction of <code>q</code>,</p>
<pre><code>uint8_t *q = (uint8_t*)(((uintptr_t)p.ptr) &amp; ~0xFF) + 5;
</code></pre>
<p>and the byte-wise mutation of <code>p.ptr</code> to construct <code>r</code>,</p>
<pre><code>p.bytes[0] = 5;
uint8_t *r = p.ptr;
</code></pre>
<p>in both baseline and CHERI-enabled programs.</p>
<p>What stands out?</p>
</li>
<li>
<p>Given that <code>q</code> and <code>r</code> appear to have identical byte representation in
memory, why does the CHERI version crash when dereferencing <code>q</code>?</p>
</li>
</ol>
<h2><a class="header" href="#source" id="source">Source</a></h2>
<p><strong>corrupt-pointer.c</strong></p>
<pre><code class="language-C">/*
 * SPDX-License-Identifier: BSD-2-Clause
 * Copyright (c) 2022 Microsoft Corporation
 */
#include &lt;assert.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdio.h&gt;

#ifdef __CHERI_PURE_CAPABILITY__
#define PRINTF_PTR &quot;#p&quot;
#else
#define PRINTF_PTR &quot;p&quot;
#endif

int
main(void)
{
	char buf[0x1FF];

	volatile union {
		char *ptr;
		char bytes[sizeof(char*)];
	} p;

	for (size_t i = 0; i &lt; sizeof(buf); i++) {
		buf[i] = i;
	}
	p.ptr = &amp;buf[0x10F];

	printf(&quot;buf=%&quot; PRINTF_PTR &quot; &amp;p=%&quot; PRINTF_PTR &quot;\n&quot;, buf, &amp;p);
	printf(&quot;p.ptr=%&quot; PRINTF_PTR &quot; (0x%zx into buf) *p.ptr=%02x\n&quot;,
	    p.ptr, p.ptr - buf, *p.ptr);

	/* One way to align the address down */
	char *q = (char*)(((uintptr_t)p.ptr) &amp; ~0xFF);
	printf(&quot;q=%&quot; PRINTF_PTR &quot; (0x%zx into buf)\n&quot;, q, q - buf);

	printf(&quot;*q=%02x\n&quot;, *q);

	/* Maybe another, assuming a little-endian machine. */
	p.bytes[0] = 0;
	char *r = p.ptr;

	printf(&quot;r=%&quot; PRINTF_PTR &quot; (0x%zx)\n&quot;, r, r - buf);
	printf(&quot;*r=%02x\n&quot;, *r);

	return 0;
}
</code></pre>
<h2><a class="header" href="#courseware" id="courseware">Courseware</a></h2>
<p>This exercise has <a href="exercises/cheri-tags/./cheri-tags.pptx">presentation materials</a> available.</p>
<h1><a class="header" href="#answers" id="answers">Answers</a></h1>
<ol start="2">
<li>
<p>Example output for the baseline program:</p>
<pre><code>buf=0x8085ba59 &amp;p=0x8085ba50
p.ptr=0x8085bb68 (0x10f into buf) *p.ptr=0f
q=0x8085bb00 (0xa7 into buf)
*q=a7
r=0x8085bb00 (0xa7)
*r=a7
</code></pre>
<p>And for the CHERI-enabled program:</p>
<pre><code>buf=0x3fffdffd71 [rwRW,0x3fffdffd71-0x3fffdfff70] &amp;p=0x3fffdffd60 [rwRW,0x3fffdffd60-0x3fffdffd70]
p.ptr=0x3fffdffe80 [rwRW,0x3fffdffd71-0x3fffdfff70] (0x10f into buf) *p.ptr=0f
q=0x3fffdffe00 [rwRW,0x3fffdffd71-0x3fffdfff70] (0x8f into buf)
*q=8f
r=0x3fffdffe00 [rwRW,0x3fffdffd71-0x3fffdfff70] (invalid) (0x8f)
In-address space security exception
</code></pre>
</li>
<li>
<p><code>gdb</code> should report something like</p>
<pre><code>Program received signal SIGPROT, CHERI protection violation
Capability tag fault caused by register cs1.
main () at ./src/exercises/cheri-tags/corrupt-pointer.c:45
45      ./src/exercises/cheri-tags/corrupt-pointer.c: No such file or directory.

Thread 1 (LWP 100057 of process 1231):
#0  main () at ./src/exercises/cheri-tags/corrupt-pointer.c:45
</code></pre>
<p>We can ask <code>gdb</code> to print out the faulting instruction:</p>
<pre><code>(gdb) x/i $pcc
=&gt; 0x101d7c &lt;main+244&gt;:     lbu     a0,0(s1)
</code></pre>
<p><em>Note:</em> due to deficiencies in the current GDB implementation, the faulting
instruction incorrectly decodes as <code>lbu</code> with integer operands rather than
correctly as <code>clbu a0, 0(cs1)</code>.</p>
<p>We can also ask <code>gdb</code> for more information about the signal we received:</p>
<pre><code>(gdb) p $_siginfo
$1 = {si_signo = 34, si_errno = 0, si_code = 2, si_pid = 0, si_uid = 0, si_status = 0, si_addr = 0x101d7c &lt;main+244&gt;, si_value = {sival_int = 0, sival_ptr = 0x0}, _reason = {_fault = {si_trapno = 28, si_capreg = 9}, _timer = {si_timerid = 28, si_overrun = 9}, _mesgq = {si_mqd = 28}, _poll = {si_band = 38654705692}, __spare__ = {__spare1__ = 38654705692, __spare2__ = {0, 0, 0, 0, 0, 0, 0}}}}

</code></pre>
<p>As said, <code>si_signo = 34</code> is <code>SIGPROT</code>, for which <code>si_code = 2</code> is
<code>PROT_CHERI_TAG</code>, indicating a missing (clear) tag as an input to a
capability instruction.  <code>gdb</code> in fact does this decoding for you, in the
reported line <code>Capability tag fault caused by register cs1</code>.  It will be
helpful to look for similar reports associated with <code>SIGPROT</code>s throughout
this book.</p>
</li>
<li>
<p>Constructing <code>r</code> is very similar on the two targets, differing only by the
use of integer- or capability-based memory instructions:</p>
<table><thead><tr><th></th><th align="left">Baseline</th><th align="left">CHERI</th></tr></thead><tbody>
<tr><td>Store</td><td align="left"><code>sb zero, 0(sp)</code></td><td align="left"><code>csb zero, 32(csp)</code></td></tr>
<tr><td>Load</td><td align="left"><code>ld s0, 0(sp)</code></td><td align="left"><code>clc cs1, 32(csp)</code></td></tr>
</tbody></table>
<p>The significant difference is in the construction of <code>q</code>.  On the baseline
architecture, it is a direct bitwise <code>and</code> of a pointer loaded from memory:</p>
<pre><code>ld   a0, 0(sp)
andi s0, a0, -256
</code></pre>
<p>On CHERI, on the other hand, the program makes explicit use of capability
manipulation instructions to...</p>
<table><thead><tr><th>Instruction</th><th>Action</th></tr></thead><tbody>
<tr><td><code>clc       ca0, 32(csp)</code></td><td>Load the capability from memory</td></tr>
<tr><td><code>cgetaddr  a1, ca0</code></td><td>Extract its address field to a register</td></tr>
<tr><td><code>andi      a1, a1, -256</code></td><td>Perform the mask operation</td></tr>
<tr><td><code>csetaddr  cs1, ca0, a1</code></td><td>Update the address field</td></tr>
</tbody></table>
<p>This longer instruction sequence serves to prove to the processor that the
resulting capability (in <code>cs1</code>) was constructed using valid transformations.
In particular, the <code>csetaddr</code> allows the processor to check that the
combination of the old capability (in <code>ca0</code>) and the new address (in <code>a1</code>)
remains <em>representable</em>.</p>
</li>
<li>
<p>While the in-memory, byte representation of <code>q</code> and <code>r</code> are identical, <code>q</code>
has been manipulated as <em>bytes</em> rather than as a <em>capability</em> and so has had
its tag zeroed.  (Specifically, the <code>csb zero, 32(csp)</code> instruction cleared
the tag associated with the 16-byte granule pointed to by <code>32(csp)</code>; the
subsequent <code>clc</code> transferred this zero tag to <code>cs1</code>.)</p>
</li>
</ol>
<h1><a class="header" href="#exercise-an-inter-stack-object-buffer-overflow" id="exercise-an-inter-stack-object-buffer-overflow">Exercise an inter-stack-object buffer overflow</a></h1>
<p>This exercise demonstrates an inter-object buffer overflow on baseline and
CHERI-enabled architectures, and asks you to characterize and fix the bug
detected by CHERI bounds enforcement.  It also asks you to use GDB for
debugging purposes.</p>
<p>By contrast to <a href="exercises/buffer-overflow-stack/../buffer-overflow-global">the globals-based example</a>, this
example uses two <em>stack</em> objects to demonstrate the overflow.  We will be able
to see the CHERI C compiler generate code to apply spatial bounds on the
capability used for the buffer pointer we pass around.</p>
<ol>
<li>
<p>Compile <code>buffer-overflow-stack.c</code> for the baseline architecture to
the binary <code>buffer-overflow-stack-baseline</code> and for the CHERI-aware
architecture to <code>buffer-overflow-stack-cheri</code>.</p>
</li>
<li>
<p>Run both programs and observe their outputs.</p>
</li>
<li>
<p>Using GDB on the core dump (or run the CHERI program under <code>gdb</code>):
Why has the CHERI program failed?</p>
</li>
<li>
<p>Compare and contrast the disassembly of the baseline and CHERI programs.
In particular, focus on the <code>write_buf</code> function and <code>main</code>'s call to it
and the information flow leading up to it.</p>
</li>
</ol>
<h2><a class="header" href="#source-1" id="source-1">Source</a></h2>
<p><strong>buffer-overflow-stack.c</strong></p>
<pre><code class="language-C">/*
 * SPDX-License-Identifier: BSD-2-Clause
 * Copyright (c) 2022 Microsoft Corporation
 */
#include &lt;assert.h&gt;
#include &lt;stddef.h&gt;
#include &lt;stdio.h&gt;

#pragma weak write_buf
void
write_buf(char *buf, size_t ix)
{
	buf[ix] = 'b';
}

int
main(void)
{
	char upper[0x10];
	char lower[0x10];

	printf(&quot;upper = %p, lower = %p, diff = %zx\n&quot;,
	    upper, lower, (size_t)(upper - lower));

	/* Assert that these get placed how we expect */
	assert((ptraddr_t)upper == (ptraddr_t)&amp;lower[sizeof(lower)]);

	upper[0] = 'a';
	printf(&quot;upper[0] = %c\n&quot;, upper[0]);

	write_buf(lower, sizeof(lower));

	printf(&quot;upper[0] = %c\n&quot;, upper[0]);

	return 0;
}
</code></pre>
<h2><a class="header" href="#courseware-1" id="courseware-1">Courseware</a></h2>
<p>This exercise has <a href="exercises/buffer-overflow-stack/./buffer-overflow-stack.pptx">presentation materials</a>
available.</p>
<h1><a class="header" href="#answers---exercise-an-inter-stack-object-buffer-overflow" id="answers---exercise-an-inter-stack-object-buffer-overflow">Answers - Exercise an inter-stack-object buffer overflow</a></h1>
<ol start="2">
<li>
<p>Expected output:</p>
<pre><code># ./buffer-overflow-stack-baseline
upper = 0x80d879d0, lower = 0x80d879c0, diff = 10
upper[0] = a
upper[0] = b
# ./buffer-overflow-stack-cheri
upper = 0x3fffdfff50, lower = 0x3fffdfff40, diff = 10
upper[0] = a
In-address space security exception
</code></pre>
</li>
<li>
<p>An example session of <code>gdb-run.sh ./buffer-overflow-stack-cheri</code> on CHERI-RISC-V:</p>
<pre><code>Reading symbols from ./buffer-overflow-stack-cheri...
Starting program: /mnt/buffer-overflow-stack-cheri
upper = 0x3fffdfff50, lower = 0x3fffdfff40, diff = 10
upper[0] = a

Program received signal SIGPROT, CHERI protection violation
Capability bounds fault caused by register ca0.
0x0000000000101ce8 in write_buf (buf=&lt;optimized out&gt;, ix=&lt;optimized out&gt;) at ./buffer-overflow-stack.c:13
13              buf[ix] = 'b';

Thread 1 (LWP 100044 of process 838):
#0  0x0000000000101ce8 in write_buf (buf=&lt;optimized out&gt;, ix=&lt;optimized out&gt;) at ./buffer-overflow-stack.c:13
#1  0x0000000000101d72 in main () at ./buffer-overflow-stack.c:31
(gdb) disass
Dump of assembler code for function write_buf:
   0x0000000000101ce0 &lt;+0&gt;:       cincoffset      ca0,ca0,a1
   0x0000000000101ce4 &lt;+4&gt;:       li      a1,98
=&gt; 0x0000000000101ce8 &lt;+8&gt;:       sb      a1,0(a0)
   0x0000000000101cec &lt;+12&gt;:      ret
End of assembler dump.
</code></pre>
<p><em>Note:</em> due to deficiencies in the current GDB implementation, the faulting
instruction incorrectly decodes as <code>sb</code> rather than correctly as <code>csb a1, 0(ca0)</code>.  Asking <code>gdb</code> about the registers with <code>info registers</code> and focusing
on the ones involved here, we see</p>
<pre><code>a0             0x3fffdfff50     274875809616
a1             0x62     98

ca0            0xd17d000007d5bf440000003fffdfff50       0x3fffdfff50 [rwRW,0x3fffdfff40-0x3fffdfff50]
ca1            0x62     0x62
</code></pre>
<p>The capability in <code>ca0</code>, which is a pointer into the <code>lower</code> buffer, has been
taken beyond the end of the allocation, as out of bounds store has been
attempted (<code>Capability bounds fault</code>).</p>
<p>But where did those bounds originate?  Heading <code>up</code> a stack frame and
<code>disass</code>embling, we see (eliding irrelevant instructions):</p>
<pre><code>(gdb) up
#1  0x0000000000101d72 in main () at ./buffer-overflow-stack.c:31
31              write_buf(lower, sizeof(lower));
(gdb) disass
Dump of assembler code for function main:
   0x0000000000101cf0 &lt;+0&gt;:       cincoffset      csp,csp,-144

   0x0000000000101d0c &lt;+28&gt;:      cincoffset      ca0,csp,48
   0x0000000000101d10 &lt;+32&gt;:      csetbounds      cs0,ca0,16

   0x0000000000101d64 &lt;+116&gt;:     li      a1,16
   0x0000000000101d66 &lt;+118&gt;:     cmove   ca0,cs0
   0x0000000000101d6a &lt;+122&gt;:     auipc   ra,0x0
   0x0000000000101d6e &lt;+126&gt;:     jalr    -138(ra) # 0x101ce0 &lt;write_buf&gt;
=&gt; 0x0000000000101d72 &lt;+130&gt;:     lbu     a0,0(s1)
</code></pre>
<p>The compiler has arranged for <code>main</code> to allocate 144 bytes on the stack by
decrementing the <em>capability stack pointer</em> register (<code>csp</code>) by 144 bytes.
Further, the compiler has placed <code>lower</code> 48 bytes up into that allocation:
<code>ca0</code> is made to point at its lowest address and then the pointer to <code>lower</code>
is materialized in <code>cs0</code> by <em>bounding</em> the capability in <code>ca0</code> to be 16
(<code>sizeof(lower)</code>) bytes long.  This capability is passed to <code>write_buf</code> in
<code>ca0</code>.</p>
</li>
<li>
<p>The code for <code>write_buf</code> function is only slightly changed.  On
RISC-V it compiles to</p>
<pre><code>&lt;write_buf&gt;:
 add     a0, a0, a1
 addi    a1, zero, 98
 sb      a1, 0(a0)
 ret
</code></pre>
<p>while on CHERI-RISC-V, it is</p>
<pre><code>&lt;write_buf&gt;:
 cincoffset      ca0, ca0, a1
 addi    a1, zero, 98
 csb     a1, 0(ca0)
 cret
</code></pre>
<p>In both cases, it amounts to displacing the pointer passed in <code>a0</code> (resp.
<code>ca0</code>) by the offset passed in <code>a1</code> and then performing a store-byte
instruction before returning.  In the baseline case, the store-byte takes an
<em>integer</em> address for its store, while in the CHERI case, the store-byte takes
a <em>capability authorizing the store</em>.  There are no conditional branches or
overt bounds checks in the CHERI instruction stream; rather, the <code>csb</code>
instruction itself enforces the requirement for authority to write to memory,
in the shape of a valid, in-bounds capability.</p>
<p>We have already seen the CHERI program's call site to <code>write_buf</code> in <code>main</code>,
and the derivation of the capability to the <code>lower</code> buffer, above.  In the
baseline version, the corresponding instructions are shown as</p>
<pre><code>(gdb) disass main
Dump of assembler code for function main:
   0x0000000000011b44 &lt;+0&gt;:       addi    sp,sp,-48

   0x0000000000011b8a &lt;+70&gt;:      mv      a0,sp
   0x0000000000011b8c &lt;+72&gt;:      li      a1,16
   0x0000000000011b8e &lt;+74&gt;:      auipc   ra,0x0
   0x0000000000011b92 &lt;+78&gt;:      jalr    -86(ra) # 0x11b38 &lt;write_buf&gt;
</code></pre>
<p>Here, the compiler has reserved only 48 bytes of stack space and has placed the
<code>lower</code> buffer at the lowest bytes of this reservation.  Thus, to pass a
pointer to the <code>lower</code> buffer to <code>write_buf</code>, the program simply copies the
stack pointer register (an <em>integer</em> register, holding an <em>address</em>) to the
argument register <code>a0</code>.  The subsequent address arithmetic derives an address
out of bounds, clobbering a byte of the <code>upper</code> register.</p>
</li>
</ol>
<h1><a class="header" href="#exercise-an-inter-global-object-buffer-overflow" id="exercise-an-inter-global-object-buffer-overflow">Exercise an inter-global-object buffer overflow</a></h1>
<p>This exercise demonstrates an inter-object buffer overflow on baseline and
CHERI-enabled architectures, and asks you to characterize and fix the bug
detected by CHERI bounds enforcement.  It also asks you to use GDB for
debugging purposes.</p>
<p>This example uses two <em>global</em> objects (in <code>.data</code>) to demonstrate an overflow.
It is worth pondering how the bounds for pointers to globals come to be set!</p>
<ol>
<li>
<p>Compile <code>buffer-overflow-global.c</code> for the baseline architecture to
the binary <code>buffer-overflow-global-baseline</code> and for the CHERI-aware
architecture to <code>buffer-overflow-global-cheri</code>.</p>
<p><strong>For this exercise, add <code>-G0</code> to your
compiler flags</strong> (this ensures <code>c</code> is not placed in the small data section
away from <code>buffer</code>).</p>
</li>
<li>
<p>Run both programs and observe the output.</p>
</li>
<li>
<p>Using GDB on the core dump (or run the CHERI program under <code>gdb</code>):
Why has the CHERI program failed?</p>
</li>
<li>
<p>Modify <code>buffer-overflow-global.c</code> to increase the buffer size from 128 bytes
to 1Mbyte + 1 byte.</p>
</li>
<li>
<p>Recompile and re-run <code>buffer-overflow-global-cheri</code>. Why does it no longer
crash, even though the buffer overflow exists in the source code? Is
the adjacent field still corrupted (i.e., has spatial safety been
violated between allocations)?</p>
</li>
<li>
<p>Modify <code>buffer-overflow-global.c</code> to restore the original buffer size of 128
bytes, and fix the bug by correcting accesses to the allocated array.</p>
</li>
<li>
<p>Recompile and run <code>buffer-overflow-global-cheri</code> to demonstrate that the
program is now able to continue.</p>
</li>
</ol>
<h2><a class="header" href="#source-files" id="source-files">Source Files</a></h2>
<p><strong>buffer-overflow-global.c</strong></p>
<pre><code class="language-C">/*
 * SPDX-License-Identifier: BSD-2-Clause-DARPA-SSITH-ECATS-HR0011-18-C-0016
 * Copyright (c) 2020 SRI International
 */
#include &lt;stdio.h&gt;

char buffer[128];
char c;

#pragma weak fill_buf
void
fill_buf(char *buf, size_t len)
{
	for (size_t i = 0; i &lt;= len; i++)
		buf[i] = 'b';
}

#include &quot;main-asserts.inc&quot;

int
main(void)
{
	(void)buffer;
	main_asserts();

	c = 'c';
	printf(&quot;c = %c\n&quot;, c);

	fill_buf(buffer, sizeof(buffer));

	printf(&quot;c = %c\n&quot;, c);

	return 0;
}
</code></pre>
<h3><a class="header" href="#support-code" id="support-code">Support code</a></h3>
<p><strong>main-asserts.inc</strong></p>
<pre><code class="language-C">/*
 * SPDX-License-Identifier: BSD-2-Clause-DARPA-SSITH-ECATS-HR0011-18-C-0016
 * Copyright (c) 2020 SRI International
 */
#include &lt;assert.h&gt;
#include &lt;stddef.h&gt;
#ifdef __CHERI_PURE_CAPABILITY__
#include &lt;cheriintrin.h&gt;
#endif

#ifndef nitems
#define	nitems(x)	(sizeof((x)) / sizeof((x)[0]))
#endif

static void
main_asserts(void)
{
	/*
	 * Ensure that overflowing `buffer` by 1 will hit `c`.
	 * In the pure-capabilty case, don't assert if the size of
	 * `buffer` requires padding.
	 */
	assert((ptraddr_t)&amp;buffer[nitems(buffer)] == (ptraddr_t)&amp;c
#ifdef __CHERI_PURE_CAPABILITY__
	    || sizeof(buffer) &lt; cheri_representable_length(sizeof(buffer))
#endif
	    );
}
</code></pre>
<h1><a class="header" href="#answers---exercise-an-inter-global-object-buffer-overflow" id="answers---exercise-an-inter-global-object-buffer-overflow">Answers - Exercise an inter-global-object buffer overflow</a></h1>
<ol start="2">
<li>
<p>Expected output:</p>
<pre><code># ./buffer-overflow-global-baseline
c = c
c = b
# ./buffer-overflow-global-cheri
c = c
In-address space security exception (core dumped)
</code></pre>
</li>
<li>
<p>Example session:</p>
<pre><code>Program received signal SIGPROT, CHERI protection violation
Capability bounds fault caused by register ca4.
fill_buf (
    buf=0x104060 &lt;buffer&gt; [rwRW,0x104060-0x1040e0] 'b' &lt;repeats 128 times&gt;,
    len=128) at src/exercises/buffer-overflow-global/buffer-overflow-global.c:11
11      in src/exercises/buffer-overflow-global/buffer-overflow-global.c
(gdb) info reg ca4
ca4            0xf17d00000439806400000000001040e0       0x1040e0 &lt;c&gt; [rwRW,0x104060-0x1040e0]
(gdb) x/i $pcc
=&gt; 0x101cc8 &lt;fill_buf+12&gt;:  sb      a3,0(a4)
</code></pre>
<p>The array has been incremented beyond the end of the allocation as out
of bounds store has been attempted (<code>Capability bounds fault</code>).
<em>Note:</em> due to deficiencies in the current GDB implementation, the
instruction incorrectly decodes as <code>sb</code> rather than correctly as:</p>
<pre><code>    1cc8: 23 00 d7 00   csb     a3, 0(ca4)
</code></pre>
</li>
<li>
<p>Expected output:</p>
<pre><code># ./buffer-overflow-global-cheri
c = c
c = c
</code></pre>
<p>To see why this occurs, examine the bounds of the buffer in <code>fill_buf</code>.</p>
<pre><code>(gdb) b fill_buf
Breakpoint 1 at 0x1cc2: file src/exercises/buffer-overflow-global/buffer-overflow-global.c, line 11.
(gdb) r
Starting program: /root/buffer-overflow-global-cheri

Breakpoint 1, fill_buf (buf=0x105000 &lt;buffer&gt; [rwRW,0x105000-0x205800] &quot;&quot;,
    len=1048577) at src/exercises/buffer-overflow-global/buffer-overflow-global.c:11
11      src/exercises/buffer-overflow-global/buffer-overflow-global.c: No such file or directory.
</code></pre>
<p>This indicates that buffer has been allocated (1024 * 1026) bytes. This
is due to the padding required to ensure that the bounds of <code>buffer</code>
don't overlap with other allocations. As a result, there as an area beyond
the end of the C-language object that is nonetheless in bounds.</p>
</li>
<li>
<p>Solution:</p>
<pre><code class="language-diff">--- buffer-overflow-global.c
+++ buffer-overflow-global.c
@@ -6,7 +6,7 @@ char c;
 void
 fill_buf(char *buf, size_t len)
 {
-       for (size_t i = 0; i &lt;= len; i++)
+       for (size_t i = 0; i &lt; len; i++)
                buf[i] = 'b';
 }
</code></pre>
</li>
<li>
<p>Expected output:</p>
<pre><code># ./buffer-overflow-global-cheri
c = c
c = c
</code></pre>
</li>
</ol>
<h1><a class="header" href="#explore-subobject-bounds" id="explore-subobject-bounds">Explore Subobject Bounds</a></h1>
<p>In the CheriABI run-time environment, bounds are typically associated with
memory allocations rather than C types.
For example, if a heap memory allocation is made for 1024 bytes, and the
structure within it is 768 bytes, then the bounds associated with a pointer
will be for the allocation size rather than the structure size.</p>
<h2><a class="header" href="#subobject-overflows" id="subobject-overflows">Subobject Overflows</a></h2>
<p>With subobject bounds, enforcement occurs on C-language objects within
allocations.
This exercise is similar to earlier buffer-overflow exercises, but is for such
an intra-object overflow. In our example, we consider an array within
another structure, overflowing onto an integer in the same allocation.</p>
<ol>
<li>
<p>Compile <code>buffer-overflow-subobject.c</code> with a baseline target and binary
name of <code>buffer-overflow-subobject-baseline</code>, and with a CHERI-enabled
target and binary name of <code>buffer-overflow-subobject-cheri</code>.</p>
</li>
<li>
<p>As in the prior exercises, run the binaries.</p>
</li>
<li>
<p>Explore why the CHERI binary didn't fail.
Run <code>buffer-overflow-subobject-cheri</code> under <code>gdb</code> and examine the bounds
of the <code>buffer</code> argument to <code>fill_buf()</code>.
To what do they correspond?</p>
</li>
<li>
<p>Recompile the <code>buffer-overflow-subobject-cheri</code> binary with the compiler
flags <code>-Xclang -cheri-bounds=subobject-safe</code>.</p>
</li>
<li>
<p>Run the program to demonstrate that the buffer overflow is now caught.</p>
</li>
<li>
<p>Run the program under <code>gdb</code> and examine the bounds again. What has changed?</p>
</li>
</ol>
<h2><a class="header" href="#deliberately-using-larger-bounds" id="deliberately-using-larger-bounds">Deliberately Using Larger Bounds</a></h2>
<p>Operations like <code>&amp;object-&gt;field</code> that move from super-object to sub-object are
very natural in C, and there is no similarly concise syntax for the reverse
operation.  Nevertheless, C programs occasionally do make use of <code>containerof</code>
constructs to do exactly that: derive a pointer to the superobject given a
pointer to a subobject within.</p>
<p>A common example is <em>intrusive</em> linked lists, as found, for example, in the BSD
<code>&lt;sys/queue.h&gt;</code>.  <code>subobject-list.c</code> is an extremely minimal example of such,
which we will use to explore the behavior of CHERI C here.</p>
<ol>
<li>
<p>Compile <code>subobject-list.c</code> for your CHERI-enabled target to
<code>subobject-list-cheri</code> and run it.</p>
</li>
<li>
<p>What is the length (limit - base) for capabilities to...</p>
<ul>
<li>the sentinel node (<code>&amp;l</code>)</li>
<li>a next pointer (<code>ile_next</code>) to a non-sentinel element</li>
<li>a previous-next pointer (<code>ile_prevnp</code>) to a non-sentinel element</li>
</ul>
</li>
<li>
<p>Recompile this program, now with <code>-Xclang -cheri-bounds=subobject-safe</code>, and
run the result.  What happens and why?</p>
</li>
<li>
<p>The CheriBSD system headers have been extended so that examples like this
which use the <code>&lt;sys/cdefs.h&gt;</code> definition of <code>__containerof</code> (or things built
atop that) will trip static assertions.  Try compiling again with <code>-Xclang -cheri-bounds=subobject-safe -DUSE_CDEFS_CONTAINEROF</code> and observe what the
compiler tells you.</p>
</li>
<li>
<p>Make the suggested change, marking <code>struct ilist_elem</code> as `` and recompile
once again (with the same flags as just above).  Run the resulting program
and observe its output.  Which bounds have not been narrowed?  Which have?
Why is that OK?</p>
</li>
</ol>
<h2><a class="header" href="#source-files-1" id="source-files-1">Source Files</a></h2>
<h3><a class="header" href="#subobject-overflows-1" id="subobject-overflows-1">Subobject Overflows</a></h3>
<p><strong>buffer-overflow-subobject.c</strong></p>
<pre><code class="language-C">/*
 * SPDX-License-Identifier: BSD-2-Clause-DARPA-SSITH-ECATS-HR0011-18-C-0016
 * Copyright (c) 2020 SRI International
 */
#include &lt;stdio.h&gt;

struct buf {
	char buffer[128];
	int i;
} b;

#pragma weak fill_buf
void
fill_buf(char *buf, size_t len)
{
	for (size_t i = 0; i &lt;= len; i++)
		buf[i] = 'b';
}

int
main(void)
{
	b.i = 'c';
	printf(&quot;b.i = %c\n&quot;, b.i);

	fill_buf(b.buffer, sizeof(b.buffer));

	printf(&quot;b.i = %c\n&quot;, b.i);

	return 0;
}

#include &quot;asserts.inc&quot;
</code></pre>
<p><strong>asserts.inc</strong></p>
<pre><code class="language-C">/*
 * SPDX-License-Identifier: BSD-2-Clause-DARPA-SSITH-ECATS-HR0011-18-C-0016
 * Copyright (c) 2020 SRI International
 */
#include &lt;stddef.h&gt;

_Static_assert(sizeof(b.buffer) == offsetof(struct buf, i),
    &quot;There must be no padding in struct buf between buffer and i members&quot;);
</code></pre>
<h3><a class="header" href="#deliberately-using-larger-bounds-1" id="deliberately-using-larger-bounds-1">Deliberately Using Larger Bounds</a></h3>
<p><strong>subobject-list.c</strong></p>
<pre><code class="language-C">/*
 * SPDX-License-Identifier: BSD-2-Clause
 * Copyright (c) 2022 Microsoft Corporation
 *
 * This exercise investigates a circular doubly-linked list with sentinels.
 */
#include &lt;stdio.h&gt;

/*
 * A list element is an intrusive structure (subobject) with a pointer to the
 * next list element and a pointer to the previous node's next pointer.  In the
 * case of an empty list, ile_prevnp points to ile_next.
 */
struct ilist_elem {
	struct ilist_elem **ile_prevnp;
	struct ilist_elem *ile_next;
};

static void
ilist_init_sentinel(struct ilist_elem *s) {
	s-&gt;ile_next = s;
	s-&gt;ile_prevnp = &amp;s-&gt;ile_next;
}

static void
ilist_insert_after(struct ilist_elem *p, struct ilist_elem *n) {
	n-&gt;ile_next = p-&gt;ile_next;
	p-&gt;ile_next = n;
	n-&gt;ile_next-&gt;ile_prevnp = &amp;n-&gt;ile_next;
	n-&gt;ile_prevnp = &amp;p-&gt;ile_next;
}

static void
ilist_remove(struct ilist_elem *e) {
	e-&gt;ile_next-&gt;ile_prevnp = e-&gt;ile_prevnp;
	*(e-&gt;ile_prevnp) = e-&gt;ile_next;
}

#define ILIST_FOREACH(h, c) \
	for(c = (h)-&gt;ile_next; c != (h); c = c-&gt;ile_next)

#ifdef USE_CDEFS_CONTAINEROF
#define ILIST_CONTAINER(elem, type, field) \
	(((elem) == NULL) ? ((type *)NULL) : __containerof((elem), type, field))
#else
#define ILIST_CONTAINER(elem, type, field) \
	(((elem) == NULL) ? ((type *)NULL) : \
		__DEQUALIFY(type*, (const volatile char *)(elem) - \
			__offsetof(type, field)))
#endif

struct obj {
	int val;
	struct ilist_elem ilist __subobject_use_container_bounds;
};

struct ilist_elem l; /* Sentinel element serves as list head */
struct obj obj1 = {1, {}};
struct obj obj2 = {2, {}};
struct obj obj3 = {3, {}};

int
main() {
	struct ilist_elem *cursor;

	ilist_init_sentinel(&amp;l);
	ilist_insert_after(&amp;l, &amp;obj2.ilist);
	ilist_insert_after(&amp;obj2.ilist, &amp;obj3.ilist);
	ilist_insert_after(&amp;l, &amp;obj1.ilist);
	ilist_remove(&amp;obj2.ilist);

	printf(&quot;Traversing list=%#p first=%#p lastnp=%#p\n&quot;,
		&amp;l, l.ile_next, l.ile_prevnp);
	ILIST_FOREACH(&amp;l, cursor) {
		struct obj *co = ILIST_CONTAINER(cursor, struct obj, ilist);
		printf(&quot; Ilist cursor=%#p\n  next=%#p\n  prevnp=%#p\n&quot;,
			cursor, cursor-&gt;ile_next, cursor-&gt;ile_prevnp);
		printf(&quot;  val field at %#p\n&quot;,
			/*
			 * This ugly bit of syntax is unfortunate, but avoids
			 * a subobject-bounds-induced trap that isn't the first
			 * one you should think about.  I'm sorry.  Just pretend
			 * this says &quot;&amp;co-&gt;val&quot; and, for extra credit, later,
			 * explain why it isn't spelled like that.
			 */
			((char *)co) + __offsetof(struct obj, val));
	}

	printf(&quot;Traversing list again, accessing superobject field...\n&quot;);
	ILIST_FOREACH(&amp;l, cursor) {
		struct obj *co = ILIST_CONTAINER(cursor, struct obj, ilist);
		printf(&quot; Ilist cursor=%#p value=%d (at %#p)\n&quot;, cursor,
			co-&gt;val, &amp;co-&gt;val);
	}
}
</code></pre>
<h2><a class="header" href="#courseware-2" id="courseware-2">Courseware</a></h2>
<p>This exercise has <a href="exercises/subobject-bounds/./subobject-bounds.pptx">presentation materials</a> available.</p>
<h1><a class="header" href="#answers---explore-subobject-bounds" id="answers---explore-subobject-bounds">Answers - Explore Subobject Bounds</a></h1>
<h2><a class="header" href="#exercise-a-subobject-buffer-overflow" id="exercise-a-subobject-buffer-overflow">Exercise a subobject buffer overflow</a></h2>
<p>This exercise demonstrates how subobject bounds can correct and array in a
structure.</p>
<ol start="2">
<li>
<p>Expected output:</p>
<pre><code># ./buffer-overflow-subobject-riscv
b.i = c
b.i = b
# ./buffer-overflow-subobject-cheri
b.i = c
b.i = b
</code></pre>
</li>
<li>
<p>Example session:</p>
<pre><code>(gdb) f fill_buf
No registers.
(gdb) b fill_buf
Breakpoint 1 at 0x1b3a: file src/exercises/buffer-overflow-subobject/buffer-overflow-subobject.c, line 13.
(gdb) r
Starting program: /root/buffer-overflow-subobject-cheri

Breakpoint 1, fill_buf (buf=0x103e50 &lt;b&gt; [rwRW,0x103e50-0x103ed4] &quot;&quot;, len=128)
    at src/exercises/buffer-overflow-subobject/buffer-overflow-subobject.c:13
13      src/exercises/buffer-overflow-subobject/buffer-overflow-subobject.c: No such file or directory.
</code></pre>
<p>The bounds are <code>132</code> bytes corresponding to the size of the underlying object.</p>
</li>
<li>
<p>Expected output:</p>
<pre><code># ./buffer-overflow-subobject-cheri
b.i = c
In-address space security exception (core dumped)
</code></pre>
</li>
<li>
<p>Example session:</p>
<pre><code>(gdb) b fill_buf
Breakpoint 1 at 0x1b3a: file src/exercises/buffer-overflow-subobject/buffer-overflow-subobject.c, line 13.
(gdb) r
Starting program: /root/buffer-overflow-subobject-cheri-subobject

Breakpoint 1, fill_buf (buf=0x103e50 &lt;b&gt; [rwRW,0x103e50-0x103ed0] &quot;&quot;, len=128)
    at src/exercises/buffer-overflow-subobject/buffer-overflow-subobject.c:13
13      src/exercises/buffer-overflow-subobject/buffer-overflow-subobject.c: No such file or directory.
</code></pre>
<p>The pointer to the buffer is now bounded to the array rather than the object.</p>
<p>Investigating further will reveal that the compiler has inserted a
bounds-setting instruction prior to the call to <code>fill_buf</code> in <code>main</code>, that
is, when the pointer to <code>b.buffer</code> is materialized.</p>
</li>
</ol>
<h2><a class="header" href="#deliberately-using-larger-bounds-2" id="deliberately-using-larger-bounds-2">Deliberately Using Larger Bounds</a></h2>
<ol>
<li>
<p>Example output:</p>
<pre><code>Traversing list=0x104320 [rwRW,0x104320-0x104340] first=0x1040e0 [rwRW,0x1040d0-0x104100] lastnp=0x104150 [rwRW,0x104130-0x104160]
 Ilist cursor=0x1040e0 [rwRW,0x1040d0-0x104100]
  next=0x104140 [rwRW,0x104130-0x104160]
  prevnp=0x104330 [rwRW,0x104320-0x104340]
  val field at 0x1040d0 [rwRW,0x1040d0-0x104100]
 Ilist cursor=0x104140 [rwRW,0x104130-0x104160]
  next=0x104320 [rwRW,0x104320-0x104340]
  prevnp=0x1040f0 [rwRW,0x1040d0-0x104100]
  val field at 0x104130 [rwRW,0x104130-0x104160]
Traversing list again, accessing superobject field...
 Ilist cursor=0x1040e0 [rwRW,0x1040d0-0x104100] value=1 (at 0x1040d0 [rwRW,0x1040d0-0x104100])
 Ilist cursor=0x104140 [rwRW,0x104130-0x104160] value=3 (at 0x104130 [rwRW,0x104130-0x104160])
</code></pre>
</li>
<li>
<p>In turn:</p>
<ul>
<li>
<p>All capabilities referencing the sentinel or its fields (including
<code>&amp;l-&gt;ile_next</code>) have length <code>0x20</code>, corresponding to <code>sizeof(struct ilist_elem</code>).</p>
</li>
<li>
<p>The next pointers in the sentinel, <code>0x1040d0 [rwRW,0x1040c0-0x1040f0]</code>, and
in the first list element, <code>0x104130 [rwRW,0x104120-0x104150]</code>, have legth
<code>0x30</code>, corresponding to <code>sizeof(struct obj)</code>.</p>
</li>
<li>
<p>The previous-next pointers in the sentinel, <code>0x104140 [rwRW,0x104120-0x104150]</code> and in the last list element, <code>0x1040e0 [rwRW,0x1040c0-0x1040f0]</code> also have length <code>0x30</code>.</p>
</li>
</ul>
</li>
<li>
<p>Example output:</p>
<pre><code>Traversing list=0x104350 [rwRW,0x104350-0x104370] first=0x104120 [rwRW,0x104120-0x104140] lastnp=0x104190 [rwRW,0x104190-0x1041a0]
 Ilist cursor=0x104120 [rwRW,0x104120-0x104140]
  next=0x104180 [rwRW,0x104180-0x1041a0]
  prevnp=0x104360 [rwRW,0x104360-0x104370]
  val field at 0x104110 [rwRW,0x104120-0x104140]
 Ilist cursor=0x104180 [rwRW,0x104180-0x1041a0]
  next=0x104350 [rwRW,0x104350-0x104370]
  prevnp=0x104130 [rwRW,0x104130-0x104140]
  val field at 0x104170 [rwRW,0x104180-0x1041a0]
Traversing list again, accessing superobject field...
In-address space security exception
</code></pre>
<p>Notice the line <code>val field at 0x104110 [rwRW,0x104120-0x104140]</code>.  This is
out of bounds!</p>
<p>The compiler has taken our use of <code>&amp;obj1.ilist</code> as an argument to
<code>ilist_insert_after</code> as license to <em>narrow</em> the bounds to just the subobject.
Indeed, the length of all <code>ile_next</code> pointers is now <code>0x20</code>.  Further, all
<code>ile_lastnp</code> pointers now have length <code>0x10</code>, the size of just the capability
they point to!</p>
</li>
<li>
<p>The compiler will emit a pair of warnings about the uses of
<code>ILIST_CONTAINER</code>:</p>
<pre><code>./subobject-list.c:75:20: error: static_assert failed due to requirement '__builtin_marked_no_subobject_bounds(struct obj) || __builtin_marked_no_subobject_bounds(struct ilist_elem)' &quot;this type is unsafe for use in containerof() with sub-objectbounds. Please mark the member/type with __subobject_use_container_bounds&quot;
</code></pre>
</li>
<li>
<p>We can take the compiler's advice in at least two ways:</p>
<ol>
<li>
<p>We could mark the <code>struct ilist_elem</code> type itself:</p>
<pre><code>struct ilist_elem {
  struct ilist_elem **ile_prevnp;
  struct ilist_elem *ile_next;
} __subobject_use_container_bounds;
</code></pre>
<p>When we run the program now, we will find that we are largely back in the
case where no sub-object bounds were applied: pointers to the sentinel
have length <code>0x20</code> and pointers to list elements have length <code>0x30</code>.
However, the <code>&amp;co-&gt;val</code> pointers are still bounded:</p>
<pre><code>Traversing list=0x104300 [rwRW,0x104300-0x104320] first=0x1040d0 [rwRW,0x1040c0-0x1040f0] lastnp=0x104140 [rwRW,0x104120-0x104150]
 Ilist cursor=0x1040d0 [rwRW,0x1040c0-0x1040f0]
  next=0x104130 [rwRW,0x104120-0x104150]
  prevnp=0x104310 [rwRW,0x104300-0x104320]
  val field at 0x1040c0 [rwRW,0x1040c0-0x1040f0]
 Ilist cursor=0x104130 [rwRW,0x104120-0x104150]
  next=0x104300 [rwRW,0x104300-0x104320]
  prevnp=0x1040e0 [rwRW,0x1040c0-0x1040f0]
  val field at 0x104120 [rwRW,0x104120-0x104150]
Traversing list again, accessing superobject field...
 Ilist cursor=0x1040d0 [rwRW,0x1040c0-0x1040f0] value=1 (at 0x1040c0 [rwRW,0x1040c0-0x1040c4])
 Ilist cursor=0x104130 [rwRW,0x104120-0x104150] value=3 (at 0x104120 [rwRW,0x104120-0x104124])
</code></pre>
</li>
<li>
<p>We can mark the <code>ilist</code> field of <code>struct obj</code>:</p>
<pre><code>struct obj {
  int val;
  struct ilist_elem ilist __subobject_use_container_bounds;
};
</code></pre>
<p>In this case, we find that the <code>ile_next</code> pointers are offset and not
bounded, while the <code>ile_prevnp</code> pointers are tightly bounded:</p>
<pre><code>Traversing list=0x104340 [rwRW,0x104340-0x104360] first=0x104110 [rwRW,0x104100-0x104130] lastnp=0x104180 [rwRW,0x104180-0x104190]
 Ilist cursor=0x104110 [rwRW,0x104100-0x104130]
  next=0x104170 [rwRW,0x104160-0x104190]
  prevnp=0x104350 [rwRW,0x104350-0x104360]
  val field at 0x104100 [rwRW,0x104100-0x104130]
 Ilist cursor=0x104170 [rwRW,0x104160-0x104190]
  next=0x104340 [rwRW,0x104340-0x104360]
  prevnp=0x104120 [rwRW,0x104120-0x104130]
  val field at 0x104160 [rwRW,0x104160-0x104190]
Traversing list again, accessing superobject field...
 Ilist cursor=0x104110 [rwRW,0x104100-0x104130] value=1 (at 0x104100 [rwRW,0x104100-0x104104])
 Ilist cursor=0x104170 [rwRW,0x104160-0x104190] value=3 (at 0x104160 [rwRW,0x104160-0x104164])
</code></pre>
</li>
</ol>
</li>
</ol>
<h1><a class="header" href="#corrupt-a-control-flow-pointer-using-a-subobject-buffer-overflow" id="corrupt-a-control-flow-pointer-using-a-subobject-buffer-overflow">Corrupt a control-flow pointer using a subobject buffer overflow</a></h1>
<p>This exercise demonstrates how CHERI pointer integrity protection prevents
a function pointer overwritten with data due to a buffer overflow from being
used for further memory access.</p>
<ol>
<li>Compile <code>buffer-overflow-fnptr.c</code> with a RISC-V target and binary name
of <code>buffer-overflow-fnptr-riscv</code>, and a CHERI-RISC-V target and binary
name of <code>buffer-overflow-fnptr-cheri</code>. Do not enable compilation with
subobject bounds protection when compiling with the CHERI-RISC-V target.</li>
</ol>
<p><strong>buffer-overflow-fnptr.c</strong></p>
<pre><code class="language-C">/*
 * SPDX-License-Identifier: BSD-2-Clause-DARPA-SSITH-ECATS-HR0011-18-C-0016
 * Copyright (c) 2020 SRI International
 */
#include &lt;stdio.h&gt;

struct buf {
	size_t length;
	int buffer[30];
	size_t (*callback)(struct buf *);
};

void
fill_buf(struct buf *bp)
{
	bp-&gt;length = sizeof(bp-&gt;buffer)/sizeof(*bp-&gt;buffer);
	for (size_t i = 0; i &lt;= bp-&gt;length; i++)
		bp-&gt;buffer[i] = 0xAAAAAAAA;
}

size_t
count_screams(struct buf *bp)
{
	int screams = 0;

	for (size_t i = 0; i &lt; bp-&gt;length; i++)
		screams += bp-&gt;buffer[i] == 0xAAAAAAAA ? 1 : 0;
	return screams;
}

struct buf b = {.callback = count_screams};

int
main(void)
{
	fill_buf(&amp;b);

	printf(&quot;Words of screaming in b.buffer %zu\n&quot;, b.callback(&amp;b));

	return 0;
}

#include &quot;asserts.inc&quot;
</code></pre>
<ol start="2">
<li>Run the RISC-V program under GDB; why does it crash?</li>
<li>Run the CHERI-RISC-V program under GDB; why does it crash?</li>
</ol>
<h2><a class="header" href="#support-code-1" id="support-code-1">Support code</a></h2>
<p><strong>asserts.inc</strong></p>
<pre><code class="language-C">/*
 * SPDX-License-Identifier: BSD-2-Clause-DARPA-SSITH-ECATS-HR0011-18-C-0016
 * Copyright (c) 2020 SRI International
 */
#include &lt;stddef.h&gt;

_Static_assert(offsetof(struct buf, buffer) + sizeof(b.buffer) ==
    offsetof(struct buf, callback),
    &quot;There must be no padding between buffer and callback members&quot;);
</code></pre>
<h1><a class="header" href="#answers---corrupt-a-control-flow-pointer-using-a-subobject-buffer-overflow" id="answers---corrupt-a-control-flow-pointer-using-a-subobject-buffer-overflow">Answers - Corrupt a control-flow pointer using a subobject buffer overflow</a></h1>
<ol start="2">
<li>Example session:</li>
</ol>
<pre><code>(gdb) r
Starting program: /root/buffer-overflow-fnptr-riscv 

Program received signal SIGSEGV, Segmentation fault.
0x00000000aaaaaaaa in ?? ()
</code></pre>
<p>The program attempted an instruction fetch from a nonsensical address
<code>0xaaaaaaaa</code>.</p>
<ol start="3">
<li>Example session:</li>
</ol>
<pre><code>(gdb) r
Starting program: /root/buffer-overflow-fnptr-cheri 

Program received signal SIGPROT, CHERI protection violation
Capability tag fault caused by register ca1.
0x0000000000101c5e in main ()
    at src/exercises/control-flow-pointer/buffer-overflow-fnptr.c:34
34      src/exercises/control-flow-pointer/buffer-overflow-fnptr.c: No such file or directory.
(gdb) info reg ca1
ca1            0xd11720000801800600000000aaaaaaaa       0xaaaaaaaa [rxR,0xaaaa0000-0xaaaa4000] (sentry)
(gdb) x/i $pcc
=&gt; 0x101c5e &lt;main+58&gt;:      cjalr   cra,ca1
</code></pre>
<p>The program attempted to load an instruction via an untagged capability <code>ca1</code>.</p>
<h1><a class="header" href="#exercise-heap-overflows" id="exercise-heap-overflows">Exercise heap overflows</a></h1>
<p>This exercise demonstrates inter-object <em>heap</em> buffer overflows on baseline and
CHERI-enabled architectures, and asks you to characterize and fix the bug
detected by CHERI bounds enforcement.</p>
<ol>
<li>
<p>Compile <code>buffer-overflow-heap.c</code> for the baseline architecture to the binary
<code>buffer-overflow-heap-baseline</code> and for the CHERI-aware architecture to
<code>buffer-overflow-heap-cheri</code>.</p>
</li>
<li>
<p>Run both versions, passing <code>0x20</code> as the (sole) command line argument.
Observe that the CHERI version crashes with &quot;In-address space security
exception&quot;.</p>
</li>
<li>
<p>Run the CHERI version, again with <code>0x20</code>, under <code>gdb</code> and examine the crash
in more detail.  Where must the bounds on the capability implementing <code>b1</code>
have come from?</p>
</li>
<li>
<p>Run both programs again, but now with <code>0x1001</code> as the argument.
Draw a picture of the portion of the heap containing (the end of) <code>b1</code> and
(the start of) <code>b2</code>.  There are, in some sense, <em>two</em> different ends of <code>b1</code>
in the baseline program and <em>three</em> in the CHERI program!  What are they and
how do they arise?</p>
</li>
<li>
<p>While this program does crash on CHERI, again of a bounds violation, this
happens slightly later than might be expected looking at the program's
source.  In particular, this program actually commits <em>two</em> out of bounds
stores using the <code>b1</code> capability.  Examine the output carefully and describe,
merely in terms of the mechanism, without venturing philosophical, why the
first does not trigger a trap.</p>
</li>
<li>
<p>Now consider the bigger picture.  Since CHERI uses <em>compressed</em> capability
bounds, what additional steps must be taken, and by whom, to ensure spatial
safety of a C program?</p>
</li>
</ol>
<h2><a class="header" href="#source-files-2" id="source-files-2">Source Files</a></h2>
<p><strong>buffer-overflow-heap.c</strong></p>
<pre><code class="language-C">/*
 * SPDX-License-Identifier: BSD-2-Clause
 * Copyright (c) 2022 Microsoft Corporation
 */
#include &lt;assert.h&gt;
#include &lt;stddef.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int
main(int argc, char **argv)
{
	char *b1, *b2;

	assert(argc == 2);
	char *p;
	size_t sz = (size_t)strtoull(argv[1], &amp;p, 0);

	assert(sz &gt; 0);
	assert(sz &lt;= 0x8000);

	b1 = malloc(sz);
	assert(b1 != NULL);

	b2 = malloc(sz);
	assert(b2 != NULL);

#ifdef __CHERI_PURE_CAPABILITY__
	printf(&quot;sz=%zx, CRRL(sz)=%zx\n&quot;, sz,
	    __builtin_cheri_round_representable_length(sz));
	printf(&quot;b1=%#p b2=%#p diff=%tx\n&quot;, b1, b2, b2 - b1);
#else
	printf(&quot;b1=%p b2=%p diff=%tx\n&quot;, b1, b2, b2 - b1);
#endif

	/*
	 * The default CheriBSD malloc uses &quot;size classes&quot; for allocations.
	 * Check that we've landed &quot;nearby&quot;.
	 */
	assert((ptraddr_t)(b1 + sz) &lt;= (ptraddr_t)b2); 
	assert((ptraddr_t)(b1 + sz + sz/2) &gt; (ptraddr_t)b2); 

	memset(b2, 'B', sz);

	printf(&quot;Overflowing by 1\n&quot;);
	memset(b1, 'A', sz + 1);

	printf(&quot;b2 begins: %.4s\n&quot;, b2);


	/* And now let's definitely make trouble */
	const size_t oversz = b2 - b1 + 2 - sz;
	printf(&quot;Overflowing by %zx\n&quot;, oversz);
	memset(b1 + sz, 'A', oversz);

	printf(&quot;b2 begins: %.4s\n&quot;, b2);
}
</code></pre>
<h2><a class="header" href="#courseware-3" id="courseware-3">Courseware</a></h2>
<p>This exercise has <a href="exercises/buffer-overflow-heap/./buffer-overflow-heap.pptx">presentation materials</a>
available.</p>
<h1><a class="header" href="#answers---exercise-heap-overflows" id="answers---exercise-heap-overflows">Answers - Exercise heap overflows</a></h1>
<ol start="2">
<li>
<p>Example output:</p>
<pre><code># ./buffer-overflow-heap-baseline 0x20
b1=0x83e82000 b2=0x83e82020 diff=20
Overflowing by 1
b2 begins: ABBB
Overflowing by 2
b2 begins: AABB
</code></pre>
<pre><code># ./buffer-overflow-heap-cheri 0x20
sz=20, CRRL(sz)=20
b1=0x407c7000 [rwRW,0x407c7000-0x407c7020] b2=0x407c7020 [rwRW,0x407c7020-0x407c7040] diff=20
Overflowing by 1
In-address space security exception
</code></pre>
</li>
<li>
<p>Example session (abridged):</p>
<pre><code># gdb-run.sh ./buffer-overflow-heap-cheri 0x20

Starting program: ./buffer-overflow-heap-cheri 0x20
sz=20, CRRL(sz)=20
b1=0x407c7000 [rwRW,0x407c7000-0x407c7020] b2=0x407c7020 [rwRW,0x407c7020-0x407c7040] diff=20
Overflowing by 1

Program received signal SIGPROT, CHERI protection violation
Capability bounds fault caused by register ca4.
memset (dst0=0x407c7000 [rwRW,0x407c7000-0x407c7020], c0=65, length=&lt;optimized out&gt;) at /cheri/source/mainline/cheribsd/lib/libc/string/memset.c:131
131     /cheri/source/mainline/cheribsd/lib/libc/string/memset.c: No such file or directory.

Thread 1 (LWP 100057 of process 960):
#0  memset (dst0=0x407c7000 [rwRW,0x407c7000-0x407c7020], c0=65, length=&lt;optimized out&gt;) at /cheri/source/mainline/cheribsd/lib/libc/string/memset.c:131
#1  0x00000000001020d2 in main (argc=&lt;optimized out&gt;, argv=&lt;optimized out&gt;) at ./src/exercises/buffer-overflow-heap/buffer-overflow-heap.c:49
(gdb) i r ca4
ca4            0xd17d00000409b00400000000407c7020       0x407c7020 [rwRW,0x407c7000-0x407c7020]
</code></pre>
<p>The capability in <code>ca4</code> is, as expected, a reference to the first allocation
(<code>b1</code>).  The bounds on this capability must have been imposed <em>by malloc</em>.</p>
</li>
<li>
<p>Example output:</p>
<pre><code># /mnt/buffer-overflow-heap-baseline 0x1001
b1=0x840ec000 b2=0x840ed400 diff=1400
Overflowing by 1
b2 begins: BBBB
Overflowing by 401
b2 begins: AABB
</code></pre>
<pre><code># /mnt/buffer-overflow-heap-cheri 0x1001
sz=1001, CRRL(sz)=1008
b1=0x407c7000 [rwRW,0x407c7000-0x407c8008] b2=0x407c8400 [rwRW,0x407c8400-0x407c9408] diff=1400
Overflowing by 1
Overflowing by 401
In-address space security exception
</code></pre>
<p>Using addresses from the CHERI run, we might draw something that highlighted
these key addresses:</p>
<table><thead><tr><th align="right">Address</th><th>Contents</th></tr></thead><tbody>
<tr><td align="right"> <code>0x000...00</code></td><td></td></tr>
<tr><td align="right"><code>0x407c7000</code></td><td>Start of <code>b1</code></td></tr>
<tr><td align="right"><code>0x407c8001</code></td><td>Last byte of <code>b1</code> allocation (&quot;end&quot; #1)</td></tr>
<tr><td align="right"><code>0x407c8002</code></td><td>Start of CHERI representation padding</td></tr>
<tr><td align="right"><code>0x407c8007</code></td><td>Last byte of CHERI representation padding (&quot;end&quot; #2)</td></tr>
<tr><td align="right"><code>0x407c8008</code></td><td>Start of allocator size-class padding</td></tr>
<tr><td align="right"><code>0x407c83FF</code></td><td>Last byte of allocator size-class padding (&quot;end&quot; #3)</td></tr>
<tr><td align="right"><code>0x407c8400</code></td><td><code>b2</code></td></tr>
<tr><td align="right"> <code>0xFFF...FF</code></td><td></td></tr>
</tbody></table>
</li>
<li>
<p>The first overflow, by 1 byte, is <em>within bounds</em> due to <em>architectural
precision</em> and so, as far as the CPU is concerned, is not an overflow despite
writing outside the logical bounds of the <code>b1</code> allocation.</p>
</li>
<li>
<p>In order to set bounds large enough to encapsulate large objects, CHERI's
compressed capability representation may be able to express only larger
bounds than the requested size.  (More generally, the <em>base</em> and <em>limit</em>s of
a capability have increased alignment requirements as they are moved further
apart, that is, as the capability length increases.  For the capabilities
in this example, the bases have strong alignments, of at least 10 bits, due
to the allocator's use of size classes.)</p>
<p>If bounds were simply widened with no additional consideration, then pointers
to different objects might come to authorize access to (parts of) each
other's memory!  In order to ensure that capabilities to distinct C objects
do not alias like this, various system components must take CHERI capability
compression into consideration:</p>
<ul>
<li>The compiler, for on-stack allocations and <a href="exercises/buffer-overflow-heap/../subobject-bounds">address-taken subobjects</a>.</li>
<li>The linker, for objects in static storage</li>
<li>The heap allocator(s), for objects in dynamic storage</li>
</ul>
<p>These concerns do not usually reach &quot;application level&quot; C.</p>
</li>
</ol>
<h1><a class="header" href="#exercise-integer-pointer-type-confusion-bug" id="exercise-integer-pointer-type-confusion-bug">Exercise integer-pointer type confusion bug</a></h1>
<p>This exercise demonstrates how CHERI distinguishes between integer and pointer
types, preventing certain types of type confusion.
In this example, a union allows an integer value to be used as a pointer,
which cannot then be dereferenced.</p>
<ol>
<li>Compile <code>union-int-ptr.c</code> with a RISC-V target and binary name of
<code>union-int-ptr-riscv</code>, and with a CHERI-RISC-V target and binary name
<code>union-int-ptr-cheri</code>.</li>
</ol>
<p><strong>union-int-ptr.c</strong></p>
<pre><code class="language-C">/*
 * SPDX-License-Identifier: BSD-2-Clause-DARPA-SSITH-ECATS-HR0011-18-C-0016
 * Copyright (c) 2020 SRI International
 */
#include &lt;stdio.h&gt;

const char hello[] = &quot;Hello World!&quot;;

union long_ptr {
	long l;
	const char *ptr;
} lp = { .ptr = hello };

void
inc_long_ptr(union long_ptr *lpp)
{
	lpp-&gt;l++;
}

int
main(void)
{
	printf(&quot;lp.ptr %s\n&quot;, lp.ptr);
	inc_long_ptr(&amp;lp);
	printf(&quot;lp.ptr %s\n&quot;, lp.ptr);

	return 0;
}
</code></pre>
<ol start="2">
<li>Run the RISC-V program. What is the result?</li>
<li>Run the CHERI-RISC-V program.  What is the result?
Run under <code>gdb</code> and explain why the program crashes in the second <code>printf</code>.</li>
</ol>
<h1><a class="header" href="#answers-exercise-integer-pointer-type-confusion-bug" id="answers-exercise-integer-pointer-type-confusion-bug">Answers: Exercise integer-pointer type confusion bug</a></h1>
<p>When the integer value is updated, with CHERI-RISC-V compilation the
pointer side will no longer be dereferenceable, as the tag has been cleared.</p>
<ol start="2">
<li>Expected output:</li>
</ol>
<pre><code># ./union-int-ptr-riscv
lp.ptr Hello World!
lp.ptr ello World!
</code></pre>
<p>The <code>long</code> member was loaded and stored as an integer (this is identical
to the way it would have been handled if the pointer member were
incremented instead).</p>
<ol start="3">
<li>Expected output:</li>
</ol>
<pre><code># ./union-int-ptr-cheri
lp.ptr Hello World!
In-address space security exception (core dumped)
</code></pre>
<p>When the <code>long</code> member was loaded and stored, it caused the tag to be
cleared on the pointer.</p>
<h1><a class="header" href="#demonstrate-pointer-injection" id="demonstrate-pointer-injection">Demonstrate pointer injection</a></h1>
<p>This exercise demonstrates how CHERI's pointer provenance validity prevents
injected pointer values from being dereferenced.
In this example code, a pointer is injected via pipe IPC, and then
dereferenced.</p>
<ol>
<li>Compile <code>long-over-pipe.c</code> with a RISC-V target and a binary name of
<code>long-over-pipe-riscv</code>, and with a CHERI-RISC-V target and a binary
name of <code>long-over-pipe-cheri</code>.</li>
</ol>
<pre><code class="language-C">/*
 * SPDX-License-Identifier: BSD-2-Clause-DARPA-SSITH-ECATS-HR0011-18-C-0016
 * Copyright (c) 2020 SRI International
 */
#include &lt;err.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

int
main(void)
{
	int fds[2];
	pid_t pid;
	long val;

	if (pipe(fds) == -1)
		err(1, &quot;pipe&quot;);
	if ((pid = fork()) == -1)
		err(1, &quot;fork&quot;);
	if (pid == 0) {
		val = 42;
		if (write(fds[0], &amp;val, sizeof(val)) != sizeof(val))
			err(1, &quot;write&quot;);
	} else {
		if (read(fds[1], &amp;val, sizeof(val)) != sizeof(val))
			err(1, &quot;read&quot;);
		printf(&quot;received %ld\n&quot;, val);
	}

	return 0;
}
</code></pre>
<ol start="2">
<li>Run the two binaries, which both send long integers over pipe IPC, and
print the sent and received values.</li>
<li>Compile <code>ptr-over-pipe.c</code> with a RISC-V target and a binary name of
<code>ptr-over-pipe-riscv</code>, and with a CHERI-RISC-V target and a binary name of
<code>ptr-over-pipe-cheri</code>.</li>
</ol>
<pre><code class="language-C">/*
 * SPDX-License-Identifier: BSD-2-Clause-DARPA-SSITH-ECATS-HR0011-18-C-0016
 * Copyright (c) 2020 SRI International
 */
#include &lt;err.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

const char hello[] = &quot;Hello world!&quot;;

int
main(void)
{
	int fds[2];
	pid_t pid;
	const char *ptr;

	if (pipe(fds) == -1)
		err(1, &quot;pipe&quot;);
	if ((pid = fork()) == -1)
		err(1, &quot;fork&quot;);
	if (pid == 0) {
		ptr = hello;
		if (write(fds[0], &amp;ptr, sizeof(ptr)) != sizeof(ptr))
			err(1, &quot;write&quot;);
	} else {
		if (read(fds[1], &amp;ptr, sizeof(ptr)) != sizeof(ptr))
			err(1, &quot;read&quot;);
		printf(&quot;received %s\n&quot;, ptr);
	}

	return 0;
}
</code></pre>
<ol start="4">
<li>Run the two binaries, which both send pointers over pipe IPC, and then
dereference the received copy to print a string.</li>
<li>Why does dereferencing the received pointer in a CHERI binary fail?</li>
</ol>
<h1><a class="header" href="#answers-1" id="answers-1">Answers</a></h1>
<ol start="2">
<li>Expected output:</li>
</ol>
<pre><code># ./long-over-pipe-riscv
received 42
# ./long-over-pipe-cheri
received 42
</code></pre>
<ol start="4">
<li>Expected output:</li>
</ol>
<pre><code># ./ptr-over-pipe-riscv
received Hello world!
# ./ptr-over-pipe-cheri
In-address space security exception (core dumped)
</code></pre>
<ol start="5">
<li>Because the tag is stripped when sent via message-passing IPC, leading
to a tag violation on dereference.</li>
</ol>
<h1><a class="header" href="#adapt-a-c-program-to-cheri-c" id="adapt-a-c-program-to-cheri-c">Adapt a C Program to CHERI C</a></h1>
<p>This excercise presents an example C program that includes capability-related
issues that might appear as bugs in software initially developed for non-CHERI
architectures.  The example C program is <code>cat(1)</code> from CheriBSD (and hence
FreeBSD) modified to introduce the issues that we want to investigate.</p>
<ol>
<li>
<p>Read Sections 4.2, 4.2.1, 4.2.3 from the
<a href="https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-947.pdf">CHERI C/C++ Programming Guide</a>.
In Section 4.2.1, read only information on the following C-language types:
<code>long</code>, <code>uintptr_t</code> and <code>char *,...</code> (pointer types).</p>
</li>
<li>
<p>Compile <code>cat/cat.c</code> and <code>cat/methods.c</code> for the baseline architecture to the
binary <code>cat-baseline</code> and for the CHERI-aware architecture to <code>cat-cheri</code>.
The compiler should print some warnings when compiling <code>cat-cheri</code>.  Save the
output to examine the warnings later.</p>
</li>
<li>
<p>Run both versions to print contents of an arbitrary file (e.g.,
<code>/etc/hostid</code>), once without any additional flags and once with the <code>-n</code>
flag.</p>
</li>
<li>
<p>Run the CHERI version, again without any additional flags, under <code>gdb</code> and
examine the crash in more detail. Use <code>gdb</code> and not <code>gdb-run.sh</code> to set
appropriate breakpoints before your program is started.</p>
</li>
<li>
<p>Get back to the compiler warnings and try to solve a bug that triggered the
crash.</p>
</li>
<li>
<p>Run the CHERI version, again with the <code>-n</code> flag, under <code>gdb</code> and examine the
crash in more detail. You can use <code>gdb-run.sh</code> this time.</p>
</li>
<li>
<p>Get back to the compiler warnings and try to solve a bug that triggered the
crash.</p>
</li>
<li>
<p>You just analysed two bugs in <code>cat</code>. How are they different and why they
trigger crashes in different ways?</p>
</li>
</ol>
<h2><a class="header" href="#source-files-3" id="source-files-3">Source Files</a></h2>
<p><strong>cat/cat.c</strong></p>
<pre><code class="language-C">/*-
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Kevin Fall.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#if 0
#ifndef lint
static char const copyright[] =
&quot;@(#) Copyright (c) 1989, 1993\n\
	The Regents of the University of California.  All rights reserved.\n&quot;;
#endif /* not lint */
#endif

#ifndef lint
#if 0
static char sccsid[] = &quot;@(#)cat.c	8.2 (Berkeley) 4/27/95&quot;;
#endif
#endif /* not lint */
#include &lt;sys/cdefs.h&gt;
__FBSDID(&quot;$FreeBSD$&quot;);

#include &lt;sys/param.h&gt;
#include &lt;sys/stat.h&gt;
#ifndef NO_UDOM_SUPPORT
#include &lt;sys/socket.h&gt;
#include &lt;sys/un.h&gt;
#include &lt;netdb.h&gt;
#endif

#include &lt;ctype.h&gt;
#include &lt;err.h&gt;
#include &lt;errno.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;locale.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;wchar.h&gt;
#include &lt;wctype.h&gt;

#include &quot;cat.h&quot;

int bflag, eflag, lflag, nflag, sflag, tflag, vflag;
int rval;
const char *filename;

static void usage(void) __dead2;
static void scanfiles(char *argv[], int verbose);

int
main(int argc, char *argv[])
{
	int ch;
	struct flock stdout_lock;

	setlocale(LC_CTYPE, &quot;&quot;);

	while ((ch = getopt(argc, argv, SUPPORTED_FLAGS)) != -1)
		switch (ch) {
		case 'b':
			bflag = nflag = 1;	/* -b implies -n */
			break;
		case 'e':
			eflag = vflag = 1;	/* -e implies -v */
			break;
		case 'l':
			lflag = 1;
			break;
		case 'n':
			nflag = 1;
			break;
		case 's':
			sflag = 1;
			break;
		case 't':
			tflag = vflag = 1;	/* -t implies -v */
			break;
		case 'u':
			setbuf(stdout, NULL);
			break;
		case 'v':
			vflag = 1;
			break;
		default:
			usage();
		}
	argv += optind;

	if (lflag) {
		stdout_lock.l_len = 0;
		stdout_lock.l_start = 0;
		stdout_lock.l_type = F_WRLCK;
		stdout_lock.l_whence = SEEK_SET;
		if (fcntl(STDOUT_FILENO, F_SETLKW, &amp;stdout_lock) == -1)
			err(EXIT_FAILURE, &quot;stdout&quot;);
	}

	if (bflag || eflag || nflag || sflag || tflag || vflag)
		scanfiles(argv, 1);
	else
		scanfiles(argv, 0);
	if (fclose(stdout))
		err(1, &quot;stdout&quot;);
	exit(rval);
	/* NOTREACHED */
}

static void
usage(void)
{

	fprintf(stderr, &quot;usage: cat [-&quot; SUPPORTED_FLAGS &quot;] [file ...]\n&quot;);
	exit(1);
	/* NOTREACHED */
}

static void
scanfiles(char *argv[], int verbose)
{
	int fd, i;
	char *path;
	FILE *fp;

	i = 0;
	fd = -1;
	while ((path = argv[i]) != NULL || i == 0) {
		if (path == NULL || strcmp(path, &quot;-&quot;) == 0) {
			filename = &quot;stdin&quot;;
			fd = STDIN_FILENO;
		} else {
			filename = path;
			fd = open(path, O_RDONLY);
		}
		if (fd &lt; 0) {
			warn(&quot;%s&quot;, path);
			rval = 1;
		} else if (verbose) {
			if (fd == STDIN_FILENO)
				do_cat((long)stdin, verbose);
			else {
				fp = fdopen(fd, &quot;r&quot;);
				do_cat((long)fp, verbose);
				fclose(fp);
			}
		} else {
			do_cat(fd, verbose);
			if (fd != STDIN_FILENO)
				close(fd);
		}
		if (path == NULL)
			break;
		++i;
	}
}
</code></pre>
<p><strong>cat/cat.h</strong></p>
<pre><code class="language-C">/*-
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Kevin Fall.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#ifndef	_CAT_H_

/*
 * Memory strategy threshold, in pages: if physmem is larger than this,
 * use a large buffer.
 */
#define	PHYSPAGES_THRESHOLD (32 * 1024)

/* Maximum buffer size in bytes - do not allow it to grow larger than this. */
#define	BUFSIZE_MAX (2 * 1024 * 1024)

/*
 * Small (default) buffer size in bytes. It's inefficient for this to be
 * smaller than MAXPHYS.
 */
#define	BUFSIZE_SMALL (MAXPHYS)

#define SUPPORTED_FLAGS &quot;belnstuv&quot;

void do_cat(long file, int verbose);

#endif /* !_CAT_H_ */
</code></pre>
<p><strong>cat/methods.c</strong></p>
<pre><code class="language-C">/*-
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Kevin Fall.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include &lt;sys/cdefs.h&gt;
__FBSDID(&quot;$FreeBSD$&quot;);

#include &lt;sys/param.h&gt;
#include &lt;sys/stat.h&gt;
#ifndef NO_UDOM_SUPPORT
#include &lt;sys/socket.h&gt;
#include &lt;sys/un.h&gt;
#include &lt;netdb.h&gt;
#endif

#include &lt;ctype.h&gt;
#include &lt;err.h&gt;
#include &lt;errno.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;locale.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;wchar.h&gt;
#include &lt;wctype.h&gt;

#include &quot;cat.h&quot;

typedef uintptr_t ptroff_t;

extern int bflag, eflag, lflag, nflag, sflag, tflag, vflag;
extern int rval;
extern const char *filename;

static ssize_t
write_off(int fildes, const void *buf, ptroff_t off, size_t nbyte)
{

	return (write(fildes, (const void *)(off + (uintptr_t)buf), nbyte));
}

static void
verbose_cat(long file)
{
	FILE *fp;
	int ch, gobble, line, prev;
	wint_t wch;

	fp = (FILE *)file;

	/* Reset EOF condition on stdin. */
	if (fp == stdin &amp;&amp; feof(stdin))
		clearerr(stdin);

	line = gobble = 0;
	for (prev = '\n'; (ch = getc(fp)) != EOF; prev = ch) {
		if (prev == '\n') {
			if (sflag) {
				if (ch == '\n') {
					if (gobble)
						continue;
					gobble = 1;
				} else
					gobble = 0;
			}
			if (nflag) {
				if (!bflag || ch != '\n') {
					(void)fprintf(stdout, &quot;%6d\t&quot;, ++line);
					if (ferror(stdout))
						break;
				} else if (eflag) {
					(void)fprintf(stdout, &quot;%6s\t&quot;, &quot;&quot;);
					if (ferror(stdout))
						break;
				}
			}
		}
		if (ch == '\n') {
			if (eflag &amp;&amp; putchar('$') == EOF)
				break;
		} else if (ch == '\t') {
			if (tflag) {
				if (putchar('^') == EOF || putchar('I') == EOF)
					break;
				continue;
			}
		} else if (vflag) {
			(void)ungetc(ch, fp);
			/*
			 * Our getwc(3) doesn't change file position
			 * on error.
			 */
			if ((wch = getwc(fp)) == WEOF) {
				if (ferror(fp) &amp;&amp; errno == EILSEQ) {
					clearerr(fp);
					/* Resync attempt. */
#ifdef __FreeBSD__
					memset(&amp;fp-&gt;_mbstate, 0, sizeof(mbstate_t));
#endif
					if ((ch = getc(fp)) == EOF)
						break;
					wch = ch;
					goto ilseq;
				} else
					break;
			}
			if (!iswascii(wch) &amp;&amp; !iswprint(wch)) {
ilseq:
				if (putchar('M') == EOF || putchar('-') == EOF)
					break;
				wch = toascii(wch);
			}
			if (iswcntrl(wch)) {
				ch = toascii(wch);
				ch = (ch == '\177') ? '?' : (ch | 0100);
				if (putchar('^') == EOF || putchar(ch) == EOF)
					break;
				continue;
			}
			if (putwchar(wch) == WEOF)
				break;
			ch = -1;
			continue;
		}
		if (putchar(ch) == EOF)
			break;
	}
	if (ferror(fp)) {
		warn(&quot;%s&quot;, filename);
		rval = 1;
		clearerr(fp);
	}
	if (ferror(stdout))
		err(1, &quot;stdout&quot;);
}

static void
raw_cat(long file)
{
	long pagesize;
	int off, rfd, wfd;
	ssize_t nr, nw;
	static size_t bsize;
	static char *buf = NULL;
	struct stat sbuf;

	rfd = (int)file;

	wfd = fileno(stdout);
	if (buf == NULL) {
		if (fstat(wfd, &amp;sbuf))
			err(1, &quot;stdout&quot;);
		if (S_ISREG(sbuf.st_mode)) {
			/* If there's plenty of RAM, use a large copy buffer */
			if (sysconf(_SC_PHYS_PAGES) &gt; PHYSPAGES_THRESHOLD)
				bsize = MIN(BUFSIZE_MAX, MAXPHYS * 8);
			else
				bsize = BUFSIZE_SMALL;
		} else {
			bsize = sbuf.st_blksize;
			pagesize = sysconf(_SC_PAGESIZE);
			if (pagesize &gt; 0)
				bsize = MAX(bsize, (size_t)pagesize);
		}
		if ((buf = malloc(bsize)) == NULL)
			err(1, &quot;malloc() failure of IO buffer&quot;);
	}
	while ((nr = read(rfd, buf, bsize)) &gt; 0)
		for (off = 0; nr; nr -= nw, off += nw)
			if ((nw = write_off(wfd, buf, off, (size_t)nr)) &lt; 0)
				err(1, &quot;write(2) failed&quot;);
	if (nr &lt; 0) {
		warn(&quot;%s&quot;, filename);
		rval = 1;
	}
}

void
do_cat(long file, int verbose)
{

	if (verbose) {
		verbose_cat(file);
	} else {
		raw_cat(file);
	}
}
</code></pre>
<h2><a class="header" href="#courseware-4" id="courseware-4">Courseware</a></h2>
<p>This exercise has <a href="exercises/adapt-c/./adapt-c.pptx">presentation materials</a> available.</p>
<h1><a class="header" href="#answers---adapt-a-c-program-to-cheri-c" id="answers---adapt-a-c-program-to-cheri-c">Answers - Adapt a C Program to CHERI C</a></h1>
<ol start="2">
<li>
<p>Example output:</p>
<pre><code># ./tools/ccc riscv64 -o /build/cat-cheri ./src/exercises/adapt-c/cat/cat.c ./src/exercises/adapt-c/cat/methods.c
Running: /output/sdk/bin/clang -target riscv64-unknown-freebsd -march=rv64gc -mabi=lp64d -mno-relax --sysroot=/output/sdk/sysroot-riscv64-purecap -g -O2 -fuse-ld=lld -Wall -Wcheri -o /build/cat-cheri ./src/exercises/adapt-c/cat/cat.c ./src/exercises/adapt-c/cat/methods.c
# ./tools/ccc riscv64-purecap -o /build/cat-cheri ./src/exercises/adapt-c/cat/cat.c ./src/exercises/adapt-c/cat/methods.c
Running: /output/sdk/bin/clang -target riscv64-unknown-freebsd -march=rv64gcxcheri -mabi=l64pc128d -mno-relax --sysroot=/output/sdk/sysroot-riscv64-purecap -g -O2 -fuse-ld=lld -Wall -Wcheri -o /build/cat-cheri ./src/exercises/adapt-c/cat/cat.c ./src/exercises/adapt-c/cat/methods.c
./src/exercises/adapt-c/cat/methods.c:70:43: warning: binary expression on capability types 'ptroff_t' (aka 'unsigned __intcap') and 'uintptr_t' (aka 'unsigned __intcap'); it is not clear which should be used as the source of provenance; currently provenance is inherited from the left-hand side [-Wcheri-provenance]
        return (write(fildes, (const void *)(off + (uintptr_t)buf), nbyte));
                                             ~~~ ^ ~~~~~~~~~~~~~~
./src/exercises/adapt-c/cat/methods.c:80:7: warning: cast from provenance-free integer type to pointer type will give pointer that can not be dereferenced [-Wcheri-capability-misuse]
        fp = (FILE *)file;
             ^
2 warnings generated.
</code></pre>
</li>
<li>
<p>Example output:</p>
<pre><code># ./cat-baseline /etc/hostid
bb5fbb47-10ab-11ec-a609-f5a47707c223
# ./cat-baseline -n /etc/hostid
     1  bb5fbb47-10ab-11ec-a609-f5a47707c223
# ./cat-cheri /etc/hostid
cat-cheri: write(2) failed: Bad address
# ./cat-cheri -n /etc/hostid
In-address space security exception (core dumped)
#
</code></pre>
</li>
<li>
<p>When run without <code>gdb</code>, <code>cat-cheri</code> prints:</p>
<pre><code># ./cat-cheri /etc/hostid
cat-cheri: write(2) failed: Bad address
</code></pre>
<p>Looking at the source code, we can see there is only one call to write(2):</p>
<pre><code># grep -R write src/exercises/adapt-c/cat
src/exercises/adapt-c/cat/methods.c:write_off(int fildes, const void *buf, ptroff_t off, size_t nbyte)
src/exercises/adapt-c/cat/methods.c:    return (write(fildes, (const void *)(off + (uintptr_t)buf), nbyte));
src/exercises/adapt-c/cat/methods.c:                    if ((nw = write_off(wfd, buf, off, (size_t)nr)) &lt; 0)
src/exercises/adapt-c/cat/methods.c:                            err(1, &quot;write(2) failed&quot;);
</code></pre>
<p>The call is in the <code>write_off()</code> function and the message with the error is
printed in case the call fails. Let's see what are arguments and result
values for the system call by setting a breakpoint for <code>write()</code> in <code>gdb</code>:</p>
<pre><code># gdb ./cat-cheri
(...)
(gdb) b write
Function &quot;write&quot; not defined.
Make breakpoint pending on future shared library load? (y or [n]) y
Breakpoint 1 (write) pending.
(gdb) r /etc/hostid
Starting program: /buildroot/cat-cheri /etc/hostid

Breakpoint 1, write (fd=1, buf=0x40810000, nbytes=37) at /source/cheribsd/lib/libc/sys/write.c:49
49      /source/cheribsd/lib/libc/sys/write.c: No such file or directory.
(gdb) info register ca0 ca1 ca2
ca0            0x1      0x1
ca1            0x40810000       0x40810000
ca2            0x25     0x25
(gdb) 
(gdb) disassemble 
Dump of assembler code for function write:
=&gt; 0x0000000040295dc4 &lt;+0&gt;:       auipc   a3,0xc2
   0x0000000040295dc8 &lt;+4&gt;:       lc      ca3,1532(a3) # 0x403583c0 &lt;_CHERI_CAPABILITY_TABLE_+2464&gt;
   0x0000000040295dcc &lt;+8&gt;:       lc      ca5,496(a3)
   0x0000000040295dd0 &lt;+12&gt;:      cjr     ca5
End of assembler dump.
(gdb) 
</code></pre>
<p>We can see that <code>write()</code> was called to write to <code>stdout</code> (<code>ca0</code>) 37 bytes
(<code>ca2</code>) from a buffer with an untagged capability (<code>ca1</code>). The <code>write()</code> libc
function does not include a trapping instruction but it jumps with <code>cjr</code>.
Let's see where it jumps to:</p>
<pre><code>(gdb) ni 4
_write () at _write.S:4
4       _write.S: No such file or directory.
(gdb) disassemble 
Dump of assembler code for function _write:
=&gt; 0x0000000040299130 &lt;+0&gt;:       li      t0,4
   0x0000000040299132 &lt;+2&gt;:       ecall
   0x0000000040299136 &lt;+6&gt;:       bnez    t0,0x4029913e &lt;_write+14&gt;
   0x000000004029913a &lt;+10&gt;:      cret
   0x000000004029913e &lt;+14&gt;:      auipc   t1,0xffffd
   0x0000000040299142 &lt;+18&gt;:      cincoffset      ct1,ct1,-846
   0x0000000040299146 &lt;+22&gt;:      cjr     ct1
End of assembler dump.
(gdb) 
</code></pre>
<p><code>write()</code> jumped to <code>_write()</code>, a system call wrapper written in assembly,
that uses the <code>ecall</code> instruction to make a system call. Let's see what is
its result:</p>
<pre><code>(gdb) ni 2
4       in _write.S
(gdb) info registers ca0 ct0
ca0            0xe      0xe
ct0            0x1      0x1
(gdb) 
</code></pre>
<p>The <code>write()</code> system call failed as the kernel set <code>ct0</code> to <code>0x1</code> and
returned errno <code>0xe</code> in <code>ca0</code>. Looking at <code>errno(2)</code> and <code>write(2)</code>, we can
conclude that we passed an incorrect address to the buffer.  It is likely
here because the capability is just the address, without a tag.</p>
</li>
<li>
<p>When compiling <code>cat-cheri</code>, the compiler printed:</p>
<pre><code>./src/exercises/adapt-c/cat/methods.c:70:43: warning: binary expression on capability types 'ptroff_t' (aka 'unsigned __intcap') and 'uintptr_t' (aka 'unsigned __intcap'); it is not clear which should be used as the source of provenance; currently provenance is inherited from the left-hand side [-Wcheri-provenance]
        return (write(fildes, (const void *)(off + (uintptr_t)buf), nbyte));
                                             ~~~ ^ ~~~~~~~~~~~~~~
</code></pre>
<p>As the <a href="https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-947.pdf">CHERI C/C++ Programming Guide</a>
says in Section 4.2.3:</p>
<blockquote>
<p>In the CHERI memory protection model, capabilities are derived from
a single other capability.</p>
</blockquote>
<p>In our case, <code>off + (uintptr_t)buf</code> resulted in an untagged capability
because <code>off</code> holds an integer value in an untagged capability and, as the
compiler warns, it is used to create a resulting capability.
In order to create a capability using the correct source capability, we can
tell the compiler that <code>off</code> does not hold a valid address with a cast:</p>
<pre><code>diff --git a/src/exercises/adapt-c/cat/methods.c b/src/exercises/adapt-c/cat/methods.c
index bb78a75..6520735 100644
--- a/src/exercises/adapt-c/cat/methods.c
+++ b/src/exercises/adapt-c/cat/methods.c
@@ -67,7 +67,7 @@ static ssize_t
 write_off(int fildes, const void *buf, ptroff_t off, size_t nbyte)
 {
 
-       return (write(fildes, (const void *)(off + (uintptr_t)buf), nbyte));
+       return (write(fildes, (const void *)((size_t)off + (uintptr_t)buf), nbyte));
 }
 
 static void
</code></pre>
</li>
<li>
<p>Example output:</p>
<pre><code># gdb-run.sh ./cat-cheri -n /etc/hostid
(...)
Starting program: /buildroot/cat-cheri -n /etc/hostid

Program received signal SIGPROT, CHERI protection violation
Capability tag fault caused by register cs2.
verbose_cat (file=&lt;optimized out&gt;) at ./src/exercises/adapt-c/cat/methods.c:87
87      ./src/exercises/adapt-c/cat/methods.c: No such file or directory.

Thread 1 (LWP 100043 of process 808):
#0  verbose_cat (file=&lt;optimized out&gt;) at ./src/exercises/adapt-c/cat/methods.c:87
#1  do_cat (file=&lt;optimized out&gt;, verbose=&lt;optimized out&gt;) at ./src/exercises/adapt-c/cat/methods.c:214
#2  0x0000000000102f1a in scanfiles (argv=&lt;optimized out&gt;, verbose=&lt;optimized out&gt;) at ./src/exercises/adapt-c/cat/cat.c:172
#3  0x0000000000102d8c in main (argc=&lt;optimized out&gt;, argv=&lt;optimized out&gt;) at ./src/exercises/adapt-c/cat/cat.c:128
(gdb) 
</code></pre>
<p><code>gdb</code> says that <code>cs2</code> triggered a CHERI exception:</p>
<pre><code>(gdb) info register cs2
cs2            0x4037a400       0x4037a400
(gdb) 
</code></pre>
<p><code>cs2</code> holds an untagged capability and the program tries to load a word using
<code>cs2</code> which violates CHERI restrictions:</p>
<pre><code>(gdb) disassemble $pcc,+4
Dump of assembler code from 0x103094 to 0x103098:
=&gt; 0x0000000000103094 &lt;do_cat+228&gt;: lw      a0,16(s2)
End of assembler dump.
(gdb) 
</code></pre>
<p>Looking at the above backtrace, we can correlate this output with the source
code and see that <code>cs2</code> holds a value of
the <code>fp</code> variable:</p>
<pre><code>(gdb) p fp
$1 = (FILE *) 0x4037a400
</code></pre>
<p>It means that for some reason <code>fp</code> became an invalid capability.</p>
</li>
<li>
<p>When compiling <code>cat-cheri</code>, the compiler printed:</p>
<pre><code>./src/exercises/adapt-c/cat/methods.c:80:7: warning: cast from provenance-free integer type to pointer type will give pointer that can not be dereferenced [-Wcheri-capability-misuse]
        fp = (FILE *)file;
             ^
</code></pre>
<p>As the <a href="https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-947.pdf">CHERI C/C++ Programming Guide</a>
says in Section 4.2:</p>
<blockquote>
<p>(...) only pointers implemented using valid capabilities can be dereferenced.</p>
</blockquote>
<p>and in Section 4.2.1:</p>
<blockquote>
<p><code>int</code>,<code>int32_t</code>,<code>long</code>,<code>int64_t</code>,... These pure integer types should be
used to hold integer values that will never be cast to a pointer type without
first combining them with another pointer value  e.g., by using them as an
array offset.</p>
</blockquote>
<p>In our case, <code>long</code> is cast to a pointer type which results in a NULL-derived
capability without a tag, with an address set to an integer value, and which
cannot be dereferenced.  We can fix this bug by using a data type that can
hold both integer values and pointers - <code>uintptr_t</code>:</p>
<pre><code>diff --git a/src/exercises/adapt-c/cat/cat.c b/src/exercises/adapt-c/cat/cat.c
index 344e505..54cc864 100644
--- a/src/exercises/adapt-c/cat/cat.c
+++ b/src/exercises/adapt-c/cat/cat.c
@@ -166,10 +166,10 @@ scanfiles(char *argv[], int verbose)
                        rval = 1;
                } else if (verbose) {
                        if (fd == STDIN_FILENO)
-                               do_cat((long)stdin, verbose);
+                               do_cat((uintptr_t)stdin, verbose);
                        else {
                                fp = fdopen(fd, &quot;r&quot;);
-                               do_cat((long)fp, verbose);
+                               do_cat((uintptr_t)fp, verbose);
                                fclose(fp);
                        }
                } else {
diff --git a/src/exercises/adapt-c/cat/cat.h b/src/exercises/adapt-c/cat/cat.h
index c88f930..047c0b7 100644
--- a/src/exercises/adapt-c/cat/cat.h
+++ b/src/exercises/adapt-c/cat/cat.h
@@ -51,6 +51,6 @@
 
 #define SUPPORTED_FLAGS &quot;belnstuv&quot;
 
-void do_cat(long file, int verbose);
+void do_cat(uintptr_t file, int verbose);
 
 #endif /* !_CAT_H_ */
diff --git a/src/exercises/adapt-c/cat/methods.c b/src/exercises/adapt-c/cat/methods.c
index bb78a75..afe29d3 100644
--- a/src/exercises/adapt-c/cat/methods.c
+++ b/src/exercises/adapt-c/cat/methods.c
@@ -71,7 +71,7 @@ write_off(int fildes, const void *buf, ptroff_t off, size_t nbyte)
 }
 
 static void
-verbose_cat(long file)
+verbose_cat(uintptr_t file)
 {
        FILE *fp;
        int ch, gobble, line, prev;
@@ -166,7 +166,7 @@ ilseq:
 }
 
 static void
-raw_cat(long file)
+raw_cat(uintptr_t file)
 {
        long pagesize;
        int off, rfd, wfd;
@@ -207,7 +207,7 @@ raw_cat(long file)
 }
 
 void
-do_cat(long file, int verbose)
+do_cat(uintptr_t file, int verbose)
 {
 
        if (verbose) {
</code></pre>
</li>
<li>
<p>The first bug resulted in a system call error because there was no capability
operation on an invalid capability. An operating system could not copy memory
from the user address space because it checked if a user process passed an
invalid capability and returned an error.</p>
<p>The second bug resulted in a CHERI exception because an invalid capability
was used to load a word from memory.</p>
</li>
</ol>
<p>For more information on the C/C++ programming languages, CHERI compiler warnings
and errors, we recommend to read the
<a href="https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-947.pdf">CHERI C/C++ Programming Guide</a>.</p>
<h1><a class="header" href="#cheriabi-showcase" id="cheriabi-showcase">CheriABI Showcase</a></h1>
<p>This exercise demonstrates several aspects of CheriABI, which defines how
CheriBSD processes are constructed, how function calls are made, how a process
interacts with the kernel through system calls, and other such foundational
details.</p>
<h2><a class="header" href="#the-kernel-voluntarily-honors-capability-bounds" id="the-kernel-voluntarily-honors-capability-bounds">The Kernel Voluntarily Honors Capability Bounds</a></h2>
<p><code>kern-read-over.c</code> demonstrates a (potential) loss of spatial safety when
pointers are passed from userspace to the kernel.  The kernel, by convention,
has full access to all of userspace memory.  Even when CheriBSD is running
CheriABI programs, this is true: the kernel holds a capability with full RWX
access to all userspace addresses.  Therefore, the kernel can act as a
<em>confused deputy</em>, accessing memory with its legitimate authority but without
intent.</p>
<ol>
<li>
<p>Compile <code>kern-read-over.c</code> for both the baseline (<code>kern-read-over-baseline</code>)
and CHERI-enabled (<code>kern-read-over-cheri</code>) architectures.</p>
</li>
<li>
<p>Run these programs and observe their outputs.</p>
</li>
<li>
<p>Focusing on the <code>read()</code> system call, what happens in the two versions of the
program.  When, in particular, does it look like the CHERI version notices
something is amiss?</p>
</li>
<li>
<p>If you have done the <a href="exercises/cheriabi/../buffer-overflow-stack">inter-stack-object buffer overflow
exercise</a>, contrast the behaviors of the two
CHERI-enabled programs.</p>
</li>
</ol>
<h2><a class="header" href="#the-process-memory-map" id="the-process-memory-map">The Process Memory Map</a></h2>
<p>In most UNIX programs, the rights to manipulate the virtual memory map are
<em>ambient</em>: any piece of code can change the virtual memory permissions
associated with a page, <code>munmap</code> pages, or even request a replacement mapping
(&quot;fixed <code>mmap</code>&quot;) almost anywhere in the address space.  This risks allowing
evasion of CHERI capabilities' protection properties, as CHERI capabilities are
interpreted in combination with the virtual memory map.</p>
<p>Therefore, the CheriBSD kernel avails itself of a <em>software permission</em> bit in
CHERI capabilities.  Such permissions are not architecturally interpreted but
are still subject to architectural protection (and so, for example, a zero
permission bit may not be set to one without simultaneously clearing the
capability tag).  In particular, CheriBSD defines <code>CHERI_PERM_SW_VMEM</code>, sets
this permission bit when returning pointers to <em>new</em> allocations of address
space, and requires that capabilities passed to address-space-manipulating
functions bear this permission.  Userspace components are free to clear this
permission when delegating access to address space.</p>
<ol>
<li>
<p>Compile <code>perm-vmem.c</code> for both the baseline (<code>perm-vmem-baseline</code>) and
CHERI-enabled (<code>perm-vmem-cheri</code>) architectures.</p>
</li>
<li>
<p>Run these programs and observe their outputs.  The <code>printf</code> format strings
for capabilities, <code>%p</code> and <code>%#p</code>, elide some usually-excessive details, and
<code>CHERI_PERM_SW_VMEM</code> is generally regarded as one such.  <code>gdb</code>'s
pretty-printing, similarly.  However, we can programmatically extract the
permissions field and display it.</p>
</li>
<li>
<p>Modify <code>perm-vmem.c</code> to verify that <code>madvise(MADV_FREE)</code> and
<code>mmap(MAP_FIXED)</code> also are permitted for the capability returned directly
from <code>mmap</code> but are not permitted for the heap-derived pointer.</p>
</li>
</ol>
<h2><a class="header" href="#extra-credit-initial-process-construction" id="extra-credit-initial-process-construction">(Extra Credit!) Initial Process Construction</a></h2>
<p>We have largely focused on program behavior <em>after</em> it has been loaded and is
running.  Let us look in a little more detail at some aspects of the initial
construction.  While modern ELF loading is well beyond the scope of this
document, and is perhaps best summarized as &quot;here be dragons&quot;, we can
nevertheless take a quick glance at some interesting features of CheriABI
startup.</p>
<ol>
<li>
<p>Compile <code>print-more.c</code> for both the baseline (<code>print-more-baseline</code>) and the
CHERI-enabled (<code>print-more-cheri</code>) architectures.</p>
</li>
<li>
<p>Run both these programs and observe their outputs.  As might be predicted,
the CHERI version reports a wide variety of capabilities to different parts
of the address space.  Run both programs several times; what do you observe?</p>
<p>Let us examine several interesting aspects of the reported capabilities.</p>
</li>
<li>
<p>Launch <code>gdb ./print-more-cheri</code> and have it start the program and stop before
running any instructions, with <code>starti</code>.  Where do we find ourselves?</p>
</li>
<li>
<p>Use <code>info inferiors</code> to obtain the child process identifier (PID) and
<code>!procstat vm NNN</code> (replacing <code>NNN</code> with the child PID) to show the initial
address space arranged by the kernel.</p>
<p>Which of these initial mappings are targeted by the values reported for
<code>&amp;rodata_const</code>, <code>&amp;relro_ptr</code>, <code>&amp;rw_ptr</code> and <code>printf</code> in step 2?  What are
the permissions for these mappings?</p>
</li>
<li>
<p>Just because the page mapping exist, however, CHERI programs need to have
capabilities installed to access them.  Here at the very beginning of a
process's life, we are in a good position to see the <em>root capabilities</em>
that the kernel makes available.  Use <code>info registers</code> to see the initial
contents of the register file.</p>
</li>
<li>
<p>Let's begin our tour with <code>csp</code>, the capability stack pointer register.</p>
<p>First, what may strike you as surprising (and why) about the stack pointer
being replaced by a capability?</p>
<p>Second, compare the address space map obtained above with the current <code>csp</code>
value; what has the kernel arranged to &quot;back&quot; the region of address space
within stack bounds?</p>
<p>If you are familiar with <a href="https://blog.qualys.com/vulnerabilities-threat-research/2017/06/19/the-stack-clash">Stack Clash
Vulnerabilities</a>,
explain how the two aspects above work in tandem to mitigate this class of
vulnerability.</p>
<p>Third, contrast the relative order of <code>&amp;argv[0]</code> and <code>&amp;stack_local</code> as
reported on the two different architectures in step 2 above.</p>
</li>
<li>
<p>Having access to the stack is all well and good, but surely there is more to
a process than that.  At the beginning of a CheriABI process's life, the
capability in <code>ca0</code> (the first &quot;argument register&quot;) points to the &quot;auxiliary
vector&quot;, an array of <code>Elf_Auxinfo</code> structures constructed by the kernel.</p>
<p><code>gdb</code> can ask the kernel for, and display, the information in the auxiliary
vector with <code>info auxv</code>.  However, the pretty-printer is not capability
aware, so let's also directly spelunk the structure.  Use some <code>gdb</code>
scripting to print out the auxiliary vector in its entirety:</p>
<pre><code>set $i = 0
while(((Elf_Auxinfo *)$ca0)[$i].a_type != 0)
p ((Elf_Auxinfo *)$ca0)[$i]
set $i = $i + 1
end
</code></pre>
<p>Use the more human-friendly <code>info auxv</code> to interpret the <code>a_type</code> values.</p>
<p>In addition to the <code>AT_ARGV</code> value we have already (indirectly) seen above,
there are many other capabilities to nearby parts of the address space,
including the initial environment vector (<code>AT_ENVV</code>) and the executable path
(<code>AT_EXECPATH</code>).</p>
<p>More usefully, however,</p>
<ul>
<li>
<p><code>AT_PHDR</code> supplies a read/write capability to the loaded executable.</p>
</li>
<li>
<p><code>AT_ENTRY</code> supplies a read/execute capability to the loaded executable,
pointed at its entrypoint.</p>
</li>
<li>
<p><code>AT_BASE</code> supplies a full read/write/execute capability to the program's
&quot;interpreter&quot; (dynamic loader).  The elevated permissions here allow the
loader to (relatively) easily relocate <em>itself</em> early in execution.</p>
</li>
</ul>
<p>From which of these capabilities are the displayed values of <code>&amp;rodata_const</code>,
<code>&amp;relro_ptr</code>, and <code>&amp;rw_ptr</code> from step 2 sourced?  What permissions have been
shed in the derivation?  How do these permissions differ from those of the
underlying page mappings?</p>
</li>
<li>
<p>The displayed value for <code>printf</code> is tagged as being a <code>(sentry)</code>.
Modify the program to attempt to display the result of computing either</p>
<ul>
<li><code>*(char *)(printf)</code> or</li>
<li><code>(void*)((uintptr_t)printf + 1)</code>.</li>
</ul>
<p>Compile and run this modified version (or both).  What happens?</p>
<p>Sentry (short for &quot;Sealed Entry&quot;) capabilities are a special form of
capabilities: they are <em>immutable</em> and <em>inert</em>, conveying to the bearer no
authority to the target, until they become the program counter, at which
point they are unsealed into being an ordinary capability.  Thus, we can
neither read through nor mutate our handle to <code>printf</code>, yet we can jump to
it.</p>
<p>If you are familiar with <a href="https://hovav.net/ucsd/dist/geometry.pdf">Return Oriented
Programming</a> and <a href="https://www.csc2.ncsu.edu/faculty/xjiang4/pubs/ASIACCS11.pdf">Jump Oriented
Programming</a>,
you may wish to consider the cumulative challenge added by CHERI's
architectural provenance requirement combined with pervasive use of sentry
capabilities for dynamically resolved symbols.</p>
</li>
</ol>
<h2><a class="header" href="#source-2" id="source-2">Source</a></h2>
<p><strong>kern-read-over.c</strong></p>
<pre><code class="language-C">/*
 * SPDX-License-Identifier: BSD-2-Clause-DARPA-SSITH-ECATS-HR0011-18-C-0016
 * Copyright (c) 2020 SRI International
 * Copyright (c) 2022 Microsoft Corporation
 */
#include &lt;assert.h&gt;
#include &lt;err.h&gt;
#include &lt;errno.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/wait.h&gt;

#define bsz 16

int
main(void)
{
	int fds[2];
	pid_t pid;

	if (pipe(fds) == -1)
		err(1, &quot;pipe&quot;);
	if ((pid = fork()) == -1)
		err(1, &quot;fork&quot;);
	if (pid == 0) {
		char out[2*bsz];
		for (size_t i = 0; i &lt; sizeof(out); i++) {
			out[i] = 0x10 + i;
		}

		if (write(fds[0], out, sizeof(out)) != sizeof(out)) {
			err(1, &quot;write&quot;);
		}
		printf(&quot;Write OK\n&quot;);
	} else {
		int res;
		char upper[bsz] = { 0 };
		char lower[bsz] = { 0 };

		waitpid(pid, NULL, 0);

		printf(&quot;lower=%p upper=%p\n&quot;, lower, upper);
		assert((ptraddr_t)upper == (ptraddr_t)&amp;lower[sizeof(lower)]);

		res = read(fds[1], lower, sizeof(lower) + sizeof(upper));
		assert(res != 0);
		if (res &gt; 0) {
			printf(&quot;Read 0x%x OK; lower[0]=0x%x upper[0]=0x%x\n&quot;,
			    res, lower[0], upper[0]);
		} else if (res &lt; 0) {
			printf(&quot;Bad read (%s); lower[0]=0x%x upper[0]=0x%x\n&quot;,
			    strerror(errno), lower[0], upper[0]);
		}
	}

	return 0;
}
</code></pre>
<p><strong>perm-vmem.c</strong></p>
<pre><code class="language-C">/*
 * SPDX-License-Identifier: BSD-2-Clause
 * Copyright (c) 2022 Microsoft Corporation
 */
#include &lt;assert.h&gt;
#include &lt;errno.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/mman.h&gt;

#ifdef __CHERI_PURE_CAPABILITY__
#include &lt;cheri/cherireg.h&gt;
#define PRINTF_PTR &quot;#p&quot;
#else
#define PRINTF_PTR &quot;p&quot;
#endif

int
main(void)
{
	char *m, *p;
	int res;

	/* Get a page from the kernel and give it back */
	p = mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE | MAP_ANON,
	    -1, 0);
	assert(p != MAP_FAILED);
	printf(&quot;Directly mapped page at p=%&quot; PRINTF_PTR &quot;\n&quot;, p);
#ifdef __CHERI_PURE_CAPABILITY__
	printf(&quot; p.perms=0x%lx\n&quot;, __builtin_cheri_perms_get(p));
#endif
	res = madvise(p, 4096, MADV_FREE);
	assert(res == 0);

	p = mmap(p, 4096, PROT_READ|PROT_WRITE, MAP_FIXED | MAP_PRIVATE | MAP_ANON,
	    -1, 0);
	assert(p != MAP_FAILED);

	res = munmap(p, 4096);
	assert(res == 0);

	/* Get a pointer to a whole page of the heap*/
	m = malloc(8192);
	p = __builtin_align_up(m, 4096);
	printf(&quot;Punching hole in the heap at p=%&quot; PRINTF_PTR &quot;\n&quot;, p);
#ifdef __CHERI_PURE_CAPABILITY__
	printf(&quot; p.perms=0x%lx\n&quot;, __builtin_cheri_perms_get(p));
#endif

	char *q = mmap(p, 4096, PROT_READ|PROT_WRITE, MAP_FIXED | MAP_PRIVATE | MAP_ANON,
	    -1, 0);
	assert(q != MAP_FAILED);

	if (madvise(p, 4096, MADV_FREE) != 0) {
		printf(&quot;madvise failed: %s\n&quot;, strerror(errno));
	}

	if (munmap(p, 4096) != 0) {
		printf(&quot;munmap failed: %s\n&quot;, strerror(errno));
	}

	printf(&quot;Done\n&quot;);
}
</code></pre>
<p><strong>print-more.c</strong></p>
<pre><code class="language-C">/*
 * SPDX-License-Identifier: BSD-2-Clause
 * Copyright (c) 2022 Microsoft Corporation
 */
#include &lt;assert.h&gt;
#include &lt;stddef.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

#ifdef __CHERI_PURE_CAPABILITY__
#define PRINTF_PTR &quot;#p&quot;
#else
#define PRINTF_PTR &quot;p&quot;
#endif

static const int rodata_const = 42;
static int (*const relro_ptr)(const char *, ...) = printf;
static int (*rw_ptr)(const char *, ...) = printf;

int
main(int argc, char **argv)
{
	int stack_local;

	printf(&quot;&amp;argv[0]=%&quot; PRINTF_PTR &quot;\n&quot;, &amp;argv[0]);
	printf(&quot; argv[0]=%&quot; PRINTF_PTR &quot;\n&quot;,  argv[0]);
	printf(&quot;&amp;stack_local=%&quot; PRINTF_PTR &quot;\n&quot;, &amp;stack_local);

	printf(&quot;&amp;rodata_const=%&quot; PRINTF_PTR &quot;\n&quot;, &amp;rodata_const);

	printf(&quot;&amp;relro_ptr=%&quot; PRINTF_PTR &quot;\n&quot;, &amp;relro_ptr);
	printf(&quot;&amp;rw_ptr=%&quot; PRINTF_PTR &quot;\n&quot;, &amp;rw_ptr);

	printf(&quot;printf=%&quot; PRINTF_PTR &quot;\n&quot;, printf);
}
</code></pre>
<h2><a class="header" href="#courseware-5" id="courseware-5">Courseware</a></h2>
<p>This exercise has <a href="exercises/cheriabi/./cheriabi.pptx">presentation materials</a> available.</p>
<h1><a class="header" href="#answers-2" id="answers-2">Answers</a></h1>
<h2><a class="header" href="#the-process-memory-map-1" id="the-process-memory-map-1">The Process Memory Map</a></h2>
<ol start="2">
<li>
<p>Example output from a baseline architecture:</p>
<pre><code>Directly mapped page at p=0x84dc0000
Punching hole in the heap at p=0x83b48000
Done
</code></pre>
<p>And from a CHERI-enabled architecture:</p>
<pre><code>Directly mapped page at p=0x40139000 [rwRW,0x40139000-0x4013a000]
 p.perms=0x7817d
Punching hole in the heap at p=0x407d1000 [rwRW,0x407d1000-0x407d3000]
 p.perms=0x6817d
munmap failed: Memory protection violation
Done
</code></pre>
</li>
<li>
<p>This amounts to adding calls to <code>madvise(p, 4096, MADV_FREE)</code> and
<code>mmap(p, 4096, PROT_READ|PROT_WRITE, MAP_FIXED|MAP_PRIVATE|MAP_ANON, -1, 0)</code>
in the right places and verifying that the operations return appropriately.
Additionally, you may wish to check <code>errno</code> in failure cases and the
<em>contents</em> of memory after <code>mmap</code> to ensure that it has, indeed, behaved as
expected in both cases.</p>
</li>
</ol>
<h2><a class="header" href="#the-kernel-as-a-potentially-confused-deputy" id="the-kernel-as-a-potentially-confused-deputy">The Kernel as a Potentially Confused Deputy</a></h2>
<ol start="2">
<li>
<p>Example output from a baseline architecture:</p>
<pre><code>Write OK
lower=0x80922400 upper=0x80922410
Read 0x20 OK; lower[0]=0x10 upper[0]=0x20
</code></pre>
<p>And from a CHERI-enabled architecture:</p>
<pre><code>Write OK
lower=0x3fffdfff28 upper=0x3fffdfff38
Bad read (Bad address); lower[0]=0x10 upper[0]=0x0
</code></pre>
</li>
<li>
<p>On the baseline architecture, the kernel dutifully writes 0x20 bytes to the
target address, regardless of the C object model.  On the CHERI architecture,
the kernel acts <em>intentionally</em> with the capability provided by userspace and
so encounters a trap when copying bytes out to userspace.  Because the kernel
updates <code>lower[0]</code>, we can conjecture that the kernel is not performing
explicit bounds checks but is rather operating under a trust-but-validate
model, handling the architectural trap when it uses <code>copyout()</code> to copy bytes
from its internal pipe buffer to the indicated userspace buffer.</p>
</li>
<li>
<p>Not all capability faults are fatal!  While the <a href="exercises/cheriabi/../buffer-overflow-stack">inter-stack-object overflow
exercise</a> let the program die of the <code>SIGPROT</code>
thrown its way, here, the kernel maps the architectural trap to a <em>failure
return</em> rather than a fatal signal.</p>
</li>
</ol>
<h2><a class="header" href="#extra-credit-initial-process-construction-1" id="extra-credit-initial-process-construction-1">(Extra Credit!) Initial Process Construction</a></h2>
<ol start="2">
<li>
<p>Example output from a baseline architecture:</p>
<pre><code>&amp;argv[0]=0x806e0d08
 argv[0]=0x806e0fd0
&amp;stack_local=0x806e0c94
&amp;rodata_const=0x105c0
&amp;relro_ptr=0x105c8
&amp;rw_ptr=0x13e18
printf=0x11c60
</code></pre>
<p>And from a CHERI-enabled architecture:</p>
<pre><code>&amp;argv[0]=0x3fbfdff8d0 [rwRW,0x3fbfdff8d0-0x3fbfdff8f0]
 argv[0]=0x3fbfdffe30 [rwRW,0x3fbfdffe30-0x3fbfdffe4a]
&amp;stack_local=0x3fffdfff6c [rwRW,0x3fffdfff6c-0x3fffdfff70]
&amp;rodata_const=0x1005c8 [rR,0x1005c8-0x1005cc]
&amp;relro_ptr=0x102f00 [rR,0x102f00-0x102f10]
&amp;rw_ptr=0x104070 [rwRW,0x104070-0x104080]
printf=0x402608d8 [rxR,0x4013a000-0x40782000] (sentry)
</code></pre>
<p>Running the baseline version multiple times should produce different output
thanks to Address Space Layout Randomization (ASLR), a popular probabilistic
countermeasure against pointer forgery.  Because CHERI offers deterministic
protection against pointer forgery by its very nature, ASLR for CheriABI
programs is turned off.</p>
</li>
<li>
<p>Example session:</p>
<pre><code>(gdb) starti
Starting program: /buildroot/print-more-cheri 

Program stopped.
rtld_start () at /cheri/source/mainline/cheribsd/libexec/rtld-elf/riscv/rtld_start.S:62
62      /cheri/source/mainline/cheribsd/libexec/rtld-elf/riscv/rtld_start.S: No such file or directory.
</code></pre>
<p>We find ourselves nowhere within <code>print-more-cheri</code> but, rather, at the very
beginning of the <em>dynamic loader</em> (<code>rtld</code>).</p>
</li>
<li>
<p>Example session for CHERI:</p>
<pre><code>(gdb) info inferiors
  Num  Description       Executable        
* 1    process 1013      /buildroot/print-more-cheri 
(gdb) !procstat vm 1013
  PID              START                END PRT    RES PRES REF SHD FLAG  TP PATH
 1013           0x100000           0x101000 r--R-    1    3   3   0 CN--- vn /buildroot/print-more-cheri
 1013           0x101000           0x102000 r-xR-    1    3   3   0 CN--- vn /buildroot/print-more-cheri
 1013           0x102000           0x104000 rw-RW    2    3   3   0 CN--- vn /buildroot/print-more-cheri
 1013           0x104000           0x105000 rw-RW    1    1   1   0 ----- df 
 1013         0x40104000         0x4010f000 r--R-   11  344  32   0 CN--- vn /libexec/ld-elf.so.1
 1013         0x4010f000         0x4012a000 r-xR-   27    0   1   0 C---- vn /libexec/ld-elf.so.1
 1013         0x4012a000         0x4012b000 rw-RW    1  344  32   0 CN--- vn /libexec/ld-elf.so.1
 1013         0x4012b000         0x4012d000 rw-RW    2  344  32   0 CN--- vn /libexec/ld-elf.so.1
 1013         0x4012d000         0x4012f000 rw-RW    1    1   1   0 ----- df 
 1013       0x3fbfd80000       0x3fbfe00000 rw-RW    1    1   1   0 ----- df 
 1013       0x3fbfe00000       0x3fffde0000 -----    0    0   0   0 G---- gd 
 1013       0x3fffde0000       0x3fffe00000 rw-RW    0    0   0   0 ---D- -- 
 1013       0x3ffffff000       0x4000000000 r-x--    1    1  13   0 ----- ph 
</code></pre>
<table><thead><tr><th>pointer</th><th>mapping</th><th>permissions</th></tr></thead><tbody>
<tr><td><code>&amp;argv[0]</code></td><td><code>0x3fbfd80000</code></td><td><code>rw-RW</code></td></tr>
<tr><td><code>argv</code></td><td>&quot;</td><td>&quot;</td></tr>
<tr><td><code>stack_local</code></td><td><code>0x3fffde0000</code></td><td><code>rw-RW</code></td></tr>
<tr><td><code>rodata_const</code></td><td><code>0x100000</code></td><td><code>r--R-</code></td></tr>
<tr><td><code>relro_ptr</code></td><td><code>0x102000</code></td><td><code>rw-RW</code></td></tr>
<tr><td><code>rw_ptr</code></td><td><code>0x104000</code></td><td><code>rw-RW</code></td></tr>
<tr><td><code>printf</code></td><td>not initially mapped</td><td>n/a</td></tr>
</tbody></table>
</li>
<li>
<p>Abridged output:</p>
<pre><code>cra            0xd117200009e18201000000004010f040       0x4010f040 &lt;rtld_start&gt; [rxR,0x40104000-0x4012f000] (sentry)
csp            0xd17d000003ff2ffe0000003fffe00000       0x3fffe00000 [rwRW,0x3fbfe00000-0x3fffe00000]
ca0            0xd17d00000785b9b40000003fbfdff9b0       0x3fbfdff9b0 [rwRW,0x3fbfdff9b0-0x3fbfdffe10]
pcc            0x4010f040       0x4010f040 &lt;rtld_start&gt;
ddc            0x0      0x0
cap_valid      0x80800003       2155872259
</code></pre>
</li>
<li>
<p>In baseline programs, the stack is bounded only by operating system measures
-- the kernel will refuse to grow what it considers to be &quot;the stack&quot; beyond
some limit.  However, architecturally, there is no <em>a priori</em> limit to stack
growth.  In CHERI, by contrast, the stack is accessed via a capability, which
must be constructed up front.</p>
<p>For the CHERI program, the kernel has backed the entirety of stack memory
with page mappings:</p>
<pre><code> 1013       0x3fbfe00000       0x3fffde0000 -----    0    0   0   0 G---- gd 
 1013       0x3fffde0000       0x3fffe00000 rw-RW    0    0   0   0 ---D- -- 
</code></pre>
<p>The latter of these is marked as &quot;growing down&quot; (the <code>D</code> in the penultimate
field) while the former is considered a &quot;guard&quot; mapping (the <code>G</code> flag and
<code>gd</code> type), serving to prevent any other claimant to the address space.</p>
<p>The initial bounds on the stack capability prevent half of Stack Clash: the
stack capability cannot authorize access to a heap region, even if, say,
indexing an on-stack array goes very far out of bounds.  The primordial guard
entry serves to prevent the second half: the heap cannot grow into the stack,
because the kernel will not use that address space to satisfy <code>mmap</code> requests
(and, moreover, no capability held by userspace, including the one in <code>csp</code>,
bears <code>CHERI_PERM_SW_VMEM</code>, so the stack or its guard cannot be torn down).</p>
<p>Traditionally, <code>argv</code> and its contents (as well as the <code>environ</code>ment vector
and indeed the entire auxiliary vector) is placed above the initial stack
pointer, so <code>&amp;argv[0]</code> is above <code>&amp;stack_local</code>.  However, here we can see
that CheriBSD chooses to locate all this initial data <em>below</em> the stack
reservation, meaning that <code>&amp;stack_local</code> is further up the address space than
<code>&amp;argv[0]</code>.  This allows the kernel to ensure that parts of this initial
state are immutable or that there exists exactly one capability to parts of
the structure (allowing for easier reasoning about capability flow in
userspace); these would not be true if this initial data were also reachable
through the stack capability.</p>
</li>
<li>
<p>Example session:</p>
<pre><code>(gdb) info auxv
3    AT_PHDR              Program headers for program    0x100040
4    AT_PHENT             Size of program header entry   56
5    AT_PHNUM             Number of program headers      11
6    AT_PAGESZ            System page size               4096
8    AT_FLAGS             Flags                          0x0
9    AT_ENTRY             Entry point of program         0x101a30
7    AT_BASE              Base address of interpreter    0x40104000
24   AT_EHDRFLAGS         ELF header e_flags             0x30005
15   AT_EXECPATH          Executable path                0x3fbfdfffa0 &quot;/mnt/tmp/print-more-cheri&quot;
18   AT_OSRELDATE         OSRELDATE                      1400051
16   AT_CANARY            Canary for SSP                 0x3fbfdfff60
17   AT_CANARYLEN         Length of the SSP canary       64
19   AT_NCPUS             Number of CPUs                 1
20   AT_PAGESIZES         Pagesizes                      0x3fbfdfff40
21   AT_PAGESIZESLEN      Number of pagesizes            24
22   AT_TIMEKEEP          Pointer to timehands           0x3ffffff020
23   AT_STACKPROT         Initial stack protection       0x3
25   AT_HWCAP             Machine-dependent CPU capability hints 0x112d
27   AT_BSDFLAGS          ELF BSD flags                  0x0
28   AT_ARGC              Argument count                 1
29   AT_ARGV              Argument vector                0x3fbfdff880
30   AT_ENVC              Environment count              16
31   AT_ENVV              Environment vector             0x3fbfdff8a0
32   AT_PS_STRINGS        Process strings                0x3fbfdfffc0
0    AT_NULL              End of vector                  0x0
(gdb)    set $i = 0
(gdb)    while(((Elf_Auxinfo *)$ca0)[$i].a_type != 0)
 &gt;   p ((Elf_Auxinfo *)$ca0)[$i]
 &gt;   set $i = $i + 1
 &gt;   end
$1 = {a_type = 3, a_un = {a_val = 1048640, a_ptr = 0x100040 [rwRW,0x100000-0x104260], a_fcn = 0x100040 [rwRW,0x100000-0x104260]}}
$2 = {a_type = 4, a_un = {a_val = 56, a_ptr = 0x38, a_fcn = 0x38}}
$3 = {a_type = 5, a_un = {a_val = 11, a_ptr = 0xb, a_fcn = 0xb}}
$4 = {a_type = 6, a_un = {a_val = 4096, a_ptr = 0x1000, a_fcn = 0x1000}}
$5 = {a_type = 8, a_un = {a_val = 0, a_ptr = 0x0, a_fcn = 0x0}}
$6 = {a_type = 9, a_un = {a_val = 1055280, a_ptr = 0x101a30 &lt;_start&gt; [rxR,0x100000-0x104260], a_fcn = 0x101a30 &lt;_start&gt; [rxR,0x100000-0x104260]}}
$7 = {a_type = 7, a_un = {a_val = 1074806784, a_ptr = 0x40104000 [rwxRW,0x40104000-0x4012f000], a_fcn = 0x40104000 [rwxRW,0x40104000-0x4012f000]}}
$8 = {a_type = 24, a_un = {a_val = 196613, a_ptr = 0x30005, a_fcn = 0x30005}}
$9 = {a_type = 15, a_un = {a_val = 273802067872, a_ptr = 0x3fbfdfffa0 [rwRW,0x3fbfdfffa0-0x3fbfdfffba], a_fcn = 0x3fbfdfffa0 [rwRW,0x3fbfdfffa0-0x3fbfdfffba]}}
$10 = {a_type = 18, a_un = {a_val = 1400051, a_ptr = 0x155cf3, a_fcn = 0x155cf3}}
$11 = {a_type = 16, a_un = {a_val = 273802067808, a_ptr = 0x3fbfdfff60 [rwRW,0x3fbfdfff60-0x3fbfdfffa0], a_fcn = 0x3fbfdfff60 [rwRW,0x3fbfdfff60-0x3fbfdfffa0]}}
$12 = {a_type = 17, a_un = {a_val = 64, a_ptr = 0x40, a_fcn = 0x40}}
$13 = {a_type = 19, a_un = {a_val = 1, a_ptr = 0x1, a_fcn = 0x1}}
$14 = {a_type = 20, a_un = {a_val = 273802067776, a_ptr = 0x3fbfdfff40 [rwRW,0x3fbfdfff40-0x3fbfdfff58], a_fcn = 0x3fbfdfff40 [rwRW,0x3fbfdfff40-0x3fbfdfff58]}}
$15 = {a_type = 21, a_un = {a_val = 24, a_ptr = 0x18, a_fcn = 0x18}}
$16 = {a_type = 22, a_un = {a_val = 274877902880, a_ptr = 0x3ffffff020 [rwRW,0x3ffffff020-0x3ffffff190], a_fcn = 0x3ffffff020 [rwRW,0x3ffffff020-0x3ffffff190]}}
$17 = {a_type = 23, a_un = {a_val = 3, a_ptr = 0x3, a_fcn = 0x3}}
$18 = {a_type = 25, a_un = {a_val = 4397, a_ptr = 0x112d, a_fcn = 0x112d}}
$19 = {a_type = 27, a_un = {a_val = 0, a_ptr = 0x0, a_fcn = 0x0}}
$20 = {a_type = 28, a_un = {a_val = 1, a_ptr = 0x1, a_fcn = 0x1}}
$21 = {a_type = 29, a_un = {a_val = 273802066048, a_ptr = 0x3fbfdff880 [rwRW,0x3fbfdff880-0x3fbfdff8a0], a_fcn = 0x3fbfdff880 [rwRW,0x3fbfdff880-0x3fbfdff8a0]}}
$22 = {a_type = 30, a_un = {a_val = 16, a_ptr = 0x10, a_fcn = 0x10}}
$23 = {a_type = 31, a_un = {a_val = 273802066080, a_ptr = 0x3fbfdff8a0 [rwRW,0x3fbfdff8a0-0x3fbfdff9b0], a_fcn = 0x3fbfdff8a0 [rwRW,0x3fbfdff8a0-0x3fbfdff9b0]}}
$24 = {a_type = 32, a_un = {a_val = 273802067904, a_ptr = 0x3fbfdfffc0 [rwRW,0x3fbfdfffc0-0x3fbfe00000], a_fcn = 0x3fbfdfffc0 [rwRW,0x3fbfdfffc0-0x3fbfe00000]}}
</code></pre>
<p><code>rodata_const</code> and <code>relro_ptr</code> could each be derived from either <code>AT_PHDR</code>
(shedding write permission) or <code>AT_BASE</code> (shedding execute); despite that the
pages are mapped read-write, the capability permissions will enforce that
they cannot be used to modify the values here.  If these are the only
(non-TCB) capabilities to those locations, then the values must, indeed, be
constant (outside bugs in the TCB).</p>
<p><code>rw_ptr</code> must, on the other hand, have come from <code>AT_PHDR</code>.</p>
</li>
<li>
<p>In either case, the program will trap and abort (<code>In-address space security exception</code>).</p>
<p>Sentries are believed to complicate would-be ROP or JOP attacks without
excessively complicating the architecture or system software.  Without, it
would be possible to locate and invoke gadgets within resolvable functions in
any loaded object, as the function must have execute permission to its entire
body, and so the capability used to reference the function would need to
(transitively) confer such rights.  Sentries let us refer to some code
without the rights to jump to any part of it except the intended entry point.
At the time of this writing, CHERI-RISC-V always, and Morello optionally,
automatically constructs sentry capabilities when executing linked control
transfers.</p>
<p>At present, the default linkage model of CHERI means that PCC has bounds of
an entire loaded <code>.text</code> segment (the executable or one of its loaded
libraries), so ensuring the use of sentries when crossing segments restricts
the ability to source gadgets to any that may exist within the segment
vulnerable to ROP or JOP injection.</p>
<p>The curious reader should seek out additional information about CHERI's
&quot;object type&quot; mechanism and sealed capabilities, of which sentries are just
one example.</p>
</li>
</ol>
<h1><a class="header" href="#extending-heap-allocators-for-cheri" id="extending-heap-allocators-for-cheri">Extending heap allocators for CHERI</a></h1>
<p>CHERI's architectural protection is driven by software -- the compiler,
linker, OS kernel, run-time linker, run-time libraries, and so on all manage
capabilities as part of their program execution.  Heap allocators, which are
integrally tied into our notions of spatial and temporal safety, are typically
extended to use CHERI in five ways:</p>
<ol>
<li>
<p>To implement spatial safety, bounds and permissions are set on returned
pointers.
<em>(In this exercise.)</em></p>
</li>
<li>
<p>To prevent bounds overlap on larger allocations from arising due to
imprecise bounds caused by capability compression, large allocations are
aligned and padded more strongly.
<em>(Not in this exercise.)</em></p>
</li>
<li>
<p>If the allocator's <code>free()</code> implementation relies on reaching allocator
metadata via its pointer argument (e.g., by looking immediately before or
after to reach free-list poointers), then the implementation must be
changed as access will otherwise be prevented by CHERI bounds and
monotonicity.
<em>(In this exercise.)</em></p>
</li>
<li>
<p>To implement temporal safety, allocated memory is registered with a
temporal-safety run-time library when allocated, to implement
kernel-assisted revocation.
On free, the memory is is held in quarantine until revocation has been
performed.
<em>(Not in this exercise.)</em></p>
</li>
<li>
<p>To handle a further set of classes of misuse and pointer corruption, it is
also important to perform validation of arguments to <code>free()</code>, such as by
checking that the pointer is to the first byte of a valid allocation.
<em>(Not in this exercise.)</em></p>
</li>
</ol>
<p>This exercise asks you to extend a simplified memory allocator with CHERI
focusing only on (1) and (3) above.
It supports only small fixed-size allocations that will not require further
alignment or padding, and we will not consider temporal safety in this
exercise.</p>
<p>The complete exercise is embodied in <code>cheri-allocator.c</code>, including the
simplified allocator and also a <code>main()</code> routine that initializes and uses the
allocator.
<code>main()</code> allocates memory, and then overflows the allocation to corrupt
internal allocator metadata, leading to a crash.
Heap metadata corruption is a powerful exploitation tool; CHERI assists with
mitigating it through pointer integrity features, but it is preferable to
deterministically close vulnlerabilities (e.g., via spatial safety).</p>
<ol>
<li>
<p>Compile <code>cheri-allocator.c</code> with a CHERI-enabled target.
Run the binary, which will crash.</p>
</li>
<li>
<p>Use GDB to demonstrate to yourself that the overflow has corrupted
allocator metadata, leading to an eventual crash during a later call to
<code>alloc_allocate()</code>.</p>
</li>
<li>
<p>Modify the allocator to use the <code>cheri_bounds_set()</code> API to set suitable
bounds on the pointer returned by <code>alloc_allocate()</code>.
Recompile <code>cheri-allocator.c</code> with a CHERI-enabled target.</p>
</li>
<li>
<p>Use GDB to demonstrate to yourself that the overflow operation now causes
an immediate crash as a result of attempting to store out of bounds, rather
than triggering a later crash due to heap metadata corruption.</p>
</li>
<li>
<p>Remove the overflow (performed with <code>memset()</code>) from the program.
Recompile <code>cheri-allocator.c</code> with a CHERI-enabled target.</p>
</li>
<li>
<p>Use GDB to explore why the program now crashes in <code>alloc_free()</code>: How did
adding bounds during allocation break later freeing of that memory?</p>
</li>
<li>
<p>Correct the bug through the use of the <code>cheri_address_get()</code> and
<code>cheri_address_set()</code> APIs, which allow transfering an address from one
capability (with one set of bounds) to another (with a different set of
bounds).
What capability should we be using to provide the new bounds?
Recompile <code>cheri-allocator.c</code> with a CHERI-enabled target.</p>
</li>
<li>
<p>Demonstrate that the program now runs successfully to completion.</p>
</li>
</ol>
<p>The resulting allocator is now substantially safer with respect to spatial
safety, preventing underflows and overflows from corrupting allocator metadata
or the contents of other allocations.
However, to continue hardening the allocator against various attacks, further
work would be required, including better validating the argument of the
<code>free()</code> function.
This would ideally test that the pointer being freed points to memory managed
by the allocator, that the pointer is in bounds, and that it points to the
start of a current allocation.
Further temporal safety also requires quarantining freed memory until all
pointers to it have been revoked.</p>
<h2><a class="header" href="#source-files-4" id="source-files-4">Source Files</a></h2>
<p><strong>cheri-allocator.c</strong></p>
<pre><code class="language-C">/*
 * SPDX-License-Identifier: BSD-2-Clause-DARPA-SSITH-ECATS-HR0011-18-C-0016
 * Copyright (c) 2022 Robert N. M. Watson
 */

#include &lt;sys/cdefs.h&gt;

#include &lt;assert.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sysexits.h&gt;

#ifdef __CHERI_PURE_CAPABILITY__
#include &lt;cheriintrin.h&gt;
#endif

/*
 * Implement a very simple allocator for a fixed-size data type, with inline
 * metadata.  Calls to alloc_allocate() return a pointer to a fixed-size byte
 * array.  Calls to alloc_free() return it to the allocator for reuse.
 *
 * The implementation is simplistic, and is designed to support an exercise
 * relating to: (a) bounds setting; and (b) monotonicty and rederivation.
 * Each allocation is described by 'struct allocation', which consists of
 * free-list pointers and an array of bytes that make up the allocation
 * itself.  Those allocations are stored as a sequential array in a global
 * variable initialised by BSS:
 *
 *  /--------- index 0 ----------\ /--------- index 1 ----------\ /--...
 *
 * +--------+-----------------...-+--------+-----------------...-+---...
 * | a_next | a_bytes[ALLOC_SIZE] | a_next | a_bytes[ALLOC_SIZE] |
 * +--------+-----------------...-+--------+-----------------...-+---...
 *
 *                                ^                              ^
 *      \_________________________/    \_________________________/
 *        If unallocated, pointer        If unallocated, pointer
 *        to next free allocation.       to next free allocation.
 *
 * Allocation storage is sized below the threshold requiring extra alignment
 * or padding to account for capability bounds compression.
 */
#define	ALLOC_SIZE		128		/* Allocation data size. */
struct alloc_storage {
	struct alloc_storage	*a_next;		/* Free list. */
	uint8_t			 a_bytes[ALLOC_SIZE];	/* Allocated memory. */
};

#define	ALLOC_MAX	16			/* Availaable allocations. */
struct alloc_storage alloc_array[ALLOC_MAX];	/* Underlying storage. */
struct alloc_storage *alloc_nextfree;		/* Next available memory. */

/*
 * Initialise the free list, pointing alloc_nextfree at the array, and then
 * chaining array entries into the list.
 */
static void
alloc_init(void)
{
	int i;

	alloc_nextfree = &amp;alloc_array[0];
	for (i = 0; i &lt; ALLOC_MAX - 1; i++)
		alloc_array[i].a_next = &amp;alloc_array[i + 1];
	alloc_array[ALLOC_MAX - 1].a_next = NULL;
	assert(alloc_array[ALLOC_MAX - 1].a_next == NULL);
}

/*
 * Allocate memory, pulling it off the free list and updating pointers as
 * needed.
 */
static void *
alloc_allocate(void)
{
	struct alloc_storage *alloc;

	if (alloc_nextfree == NULL)
		return (NULL);
	alloc = alloc_nextfree;
	alloc_nextfree = alloc-&gt;a_next;
	alloc-&gt;a_next = NULL;

	/* Return pointer to allocated memory. */
	return (alloc-&gt;a_bytes);
};

/*
 * Free memory, inserting it back into the free list.  Note use of
 * __containerof() to convert pointer to a_bytes back into the container
 * struct pointer.
 */
static void
alloc_free(void *ptr)
{
	struct alloc_storage *alloc;

	/* Convert pointer to allocated memory into pointer to metadata. */
	alloc = __containerof(ptr, struct alloc_storage, a_bytes);
	alloc-&gt;a_next = alloc_nextfree;
	alloc_nextfree = alloc;
}

int
main(void)
{
	void *ptr1, *ptr2, *ptr3;

	/* Initialise allocator. */
	alloc_init();
	printf(&quot;Allocator initialised\n&quot;);

	/*
	 * Allocate some memory.
	 */
	printf(&quot;Allocating memory\n&quot;);
	ptr1 = alloc_allocate();
	printf(&quot;Allocation returned %p\n&quot;, ptr1);

	/*
	 * Run off the end of the memory allocation, corrupting the next
	 * allocation's metadata.  Free when done.
	 */
	printf(&quot;Preparing to overflow %p\n&quot;, ptr1);
	memset(ptr1 + ALLOC_SIZE, 'A', sizeof(void *));
	printf(&quot;Overflowed allocation %p\n&quot;, ptr1);

	printf(&quot;Freeing allocation %p\n&quot;, ptr1);
	alloc_free(ptr1);
	printf(&quot;Allocation %p freed\n&quot;, ptr1);

	/*
	 * Perform three sequential allocations to cause the allocator to
	 * dereference the corrupted pointer, performing a store.
	 */
	printf(&quot;Allocating memory\n&quot;);
	ptr1 = alloc_allocate();
	printf(&quot;Allocation returned %p\n&quot;, ptr1);

	printf(&quot;Allocating memory\n&quot;);
	ptr2 = alloc_allocate();
	printf(&quot;Allocation returned %p\n&quot;, ptr2);

	printf(&quot;Allocating memory\n&quot;);
	ptr3 = alloc_allocate();
	printf(&quot;Allocation returned %p\n&quot;, ptr3);

	/*
	 * Clear up the mess.
	 */
	printf(&quot;Freeing allocation %p\n&quot;, ptr3);
	alloc_free(ptr3);
	printf(&quot;Allocation %p freed\n&quot;, ptr3);

	printf(&quot;Freeing allocation %p\n&quot;, ptr2);
	alloc_free(ptr2);
	printf(&quot;Allocation %p freed\n&quot;, ptr2);

	printf(&quot;Freeing allocation %p\n&quot;, ptr1);
	alloc_free(ptr1);
	printf(&quot;Allocation %p freed\n&quot;, ptr1);

	exit(EX_OK);
}
</code></pre>
<h1><a class="header" href="#answers-3" id="answers-3">Answers</a></h1>
<h2><a class="header" href="#introducing-heap-allocator-bounds" id="introducing-heap-allocator-bounds">Introducing heap-allocator bounds</a></h2>
<ol start="2">
<li>GDB will show a CHERI tag violation resulting from <code>memset()</code> overwriting
the <code>a_next</code> field in the second allocation entry, which is tripped over by
a later call to <code>alloc_allocate()</code>:</li>
</ol>
<pre><code>Starting program: /opt/cheri-exercises/cheri-allocator-cheri 
Allocator initialised
Allocating memory
Allocation returned 0x104830
Preparing to overflow 0x104830
Overflowed allocation 0x104830
Freeing allocation 0x104830
Allocation 0x104830 freed
Allocating memory
Allocation returned 0x104830
Allocating memory
Allocation returned 0x1048c0
Allocating memory

Program received signal SIGPROT, CHERI protection violation
Capability tag fault caused by register ca2.
0x0000000000102374 in alloc_allocate ()
</code></pre>
<ol start="3">
<li>When compiling for CHERI C, use <code>cheri_bounds_set()</code> to set bounds on the
returned pointer:</li>
</ol>
<pre><code>        /* Return pointer to allocated memory. */
#ifdef __CHERI_PURE_CAPABILITY__
        return (cheri_bounds_set(alloc-&gt;a_bytes, ALLOC_SIZE));
#else
        return (alloc-&gt;a_bytes);
#endif
</code></pre>
<ol start="4">
<li>With this change, the <code>memset()</code> call in <code>main()</code> triggers a bounds
violation exception on overflow:</li>
</ol>
<pre><code>Starting program: /opt/cheri-exercises/cheri-allocator-cheri 
Allocator initialised
Allocating memory
Allocation returned 0x104840
Preparing to overflow 0x104840

Program received signal SIGPROT, CHERI protection violation
Capability bounds fault caused by register ca3.
memset (dst0=0x1048c0 &lt;alloc_array+144&gt; [rwRW,0x104840-0x1048c0], c0=65, 
    length=15) at /home/rnw24/cheri/cheribsd/lib/libc/string/memset.c:94
</code></pre>
<h2><a class="header" href="#reaching-allocator-metadata" id="reaching-allocator-metadata">Reaching allocator metadata</a></h2>
<ol start="6">
<li>Following this change, <code>alloc_free()</code> crashes with a bounds violation,
due to reaching outside the bounds of the passed memory allocation:</li>
</ol>
<pre><code>Starting program: /opt/cheri-exercises/cheri-allocator-cheri 
Allocator initialised
Allocating memory
Allocation returned 0x1046e0
Freeing allocation 0x1046e0

Program received signal SIGPROT, CHERI protection violation
Capability bounds fault caused by register ca3.
0x00000000001022fe in alloc_free ()
(gdb) bt
#0  0x00000000001022fe in alloc_free ()
#1  0x0000000000101f52 in main ()
</code></pre>
<ol start="7">
<li>We need to create a new capability, derived from <code>alloc_array</code> but with the
address generated from pointer to the memory being freed.
One way to do this is using the <code>cheri_address_get()</code> and
<code>cheri_address_set()</code>, reading the address from one capability and setting
it on the other:</li>
</ol>
<pre><code>#ifdef __CHERI_PURE_CAPABILITY__
        /*
         * Generate a new pointer to the allocation that is derived from the
         * one passed by the consumer.
         */
        ptr = cheri_address_set(alloc_array, cheri_address_get(ptr));
#endif
</code></pre>
<p>Note that this is not a complete solution to providing spatial safety here:
software could still accidentally pass an out-of-bounds pointer.</p>
<h1><a class="header" href="#demonstrate-pointer-revocation" id="demonstrate-pointer-revocation">Demonstrate pointer revocation</a></h1>
<h2><a class="header" href="#indirect-control-flow-through-aliased-heap-objects" id="indirect-control-flow-through-aliased-heap-objects">Indirect control flow through aliased heap objects</a></h2>
<p>This exercise demonstrates CheriBSD's <em>pointer revocation</em> facility and its use
by the system <code>malloc</code>. It asks you to contrast the same program,
<code>temporal-control.c</code>, built and run in three slightly different environments.
It must be run on a <strong>heap-temporal-safety enabled</strong> version of CheriBSD; at the
time of writing, heap temporal safety remains an experimental feature not yet
merged to mainline CheriBSD.</p>
<ol>
<li>Compile <code>temporal-control.c</code> with a RISC-V target and a binary name of
<code>temporal-control-riscv</code>.</li>
</ol>
<p><strong>temporal-control.c</strong></p>
<pre><code class="language-C">/*
 * SPDX-License-Identifier: BSD-2-Clause
 * Copyright (c) 2020 Microsoft, Inc.
 */
#include &lt;assert.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

/* Ensure we're being run on a temporal-safety-aware system */
#ifdef __CHERI_PURE_CAPABILITY__
#include &lt;cheri/revoke.h&gt;
__attribute__((used))
static void *check_cheri_revoke = cheri_revoke;

extern void malloc_revoke(void);
__attribute__((used))
static void *check_malloc_revoke = malloc_revoke;
#endif

static void
fn1(uintptr_t arg)
{
	fprintf(stderr, &quot; First function: %#p\n&quot;, (void *)arg);
}

static void
fn2(uintptr_t arg)
{
	fprintf(stderr, &quot; Second function: %#p\n&quot;, (void *)arg);
}

struct obj {
	char buf[32];
	/*
	 * The following are marked volatile to ensure the compiler doesn't
	 * constant propagate fn (making aliasing not work) and to ensure
	 * neither stores to them are optimised away entirely as dead due
	 * to calling free.
	 */
	void (* volatile fn)(uintptr_t);
	volatile uintptr_t arg;
};

int
main(void)
{
	struct obj * volatile obj1 = calloc(1, sizeof(*obj1));

	fprintf(stderr, &quot;Installing function pointer in obj1 at %#p\n&quot;, obj1);
	obj1-&gt;fn = fn1;
	obj1-&gt;arg = (uintptr_t)obj1;

	free(obj1);

	fprintf(stderr, &quot;Demonstrating use after free:\n&quot;);
	obj1-&gt;fn(obj1-&gt;arg);

#ifdef CAPREVOKE
	/* Force recycling the free queue now, but with a revocation pass */
	malloc_revoke();
#endif

	struct obj * volatile obj2 = malloc(sizeof(*obj2));
#ifdef CAPREVOKE
	assert(obj1 == obj2);
#endif

	fprintf(stderr, &quot;Assigning function pointer through obj2 at %#p\n&quot;,
	    obj2);
	obj2-&gt;fn = fn2;

	fprintf(stderr, &quot;Calling function pointer through obj1 (now %#p):\n&quot;,
	    obj1);
	obj1-&gt;fn(obj1-&gt;arg);

	return (0);
}
</code></pre>
<ol start="2">
<li>Run the resulting program and observe that the system malloc has <strong>reused</strong>
a location on the heap, such that <code>obj1</code> and <code>obj2</code> point to the same address.
Moreover, the assignment of <code>fn2</code> into <code>obj2</code> causes the last printout to be
from <code>fn2</code>, not <code>fn1</code>, even though the function pointer was fetched through
<code>obj1</code> and <code>obj1-&gt;fn</code> was last set to <code>fn1</code>.</li>
<li>Recompile <code>temporal-control.c</code> with a CHERI-RISC-V target and binary name of
<code>temporal-control-cheri</code>.</li>
<li>Run this program instead. Why does it no longer exhibit the behavior from
step 2? Ponder the suitability of using just this approach for fixing temporal
aliasing.</li>
<li>Recompile <code>temporal-control.c</code>, adding <code>-DCAPREVOKE</code> to the command line
this time, with a CHERI-RISC-V target and a binary name of
<code>temporal-control-cheri-revoke</code>.</li>
<li>Run this third program instead and note that it crashes, catching a
<code>SIGPROT</code> between declaring its intent to call <code>obj1-&gt;fn</code> and declaring that it
has made the call. Can you spot why it has crashed?</li>
<li>Rerun the third program under <code>gdb</code> and look at both the instruction
triggering the <code>SIGPROT</code> and the register(s) involved. Why is the program
crashing? What must have happened while the system was executing the
mysterious <code>malloc_revoke()</code> function?</li>
<li>Modify <code>temporal-control.c</code> to try to induce aliasing by making many
allocations: call <code>malloc</code> and <code>free</code> repeatedly until the new allocation
compares equal to <code>obj1</code>. Ah ha, you've caught the allocator now! But wait,
what is <code>obj1</code> in full (i.e., as a capability, not merely a virtual address)?
You likely have to call <code>free</code> in the loop for this exercise to work; merely
calling <code>malloc</code> may instead simply always return new addresses, even if the
initial <code>obj1</code> has been <code>free</code>-d.</li>
</ol>
<h2><a class="header" href="#more-attacks-through-aliased-heap-objects" id="more-attacks-through-aliased-heap-objects">More attacks through aliased heap objects</a></h2>
<p>The program is called <code>temporal-control.c</code> because it exhibits <em>temporal
aliasing</em> of heap pointers and because the class of bugs it mimics involve
transfers of control through function pointers held in heap objects. While
CHERI protects against pointer <em>injection</em>, it cannot so easily defend against
either:</p>
<ul>
<li><em>capability farming</em>: as in the example, a legitimately-held capability can
be (caused to be) stored to a &quot;new&quot; heap object, altering an aliased view while
preserving the set tag bit; or</li>
<li><em>data-based</em> corruption through temporal aliasing.</li>
</ul>
<p>These windows open wider considering that, unlike this example, temporal
aliasing often comes paired with <em>type-confusion</em>, so it may be possible to
overlap an easily-controlled structure with an exploitable one.</p>
<ol>
<li>Write a program like <code>temporal-control.c</code> in which changing a <em>data byte</em>
within a temporally-aliased heap object suffices to cause the program to error.
Perhaps the heap object is the state associated with a client session and
contains a flag that indicates superuser status.</li>
<li>Demonstrate that this program fails as expected on RISC-V but that any
attempt to induce aliasing is thwarted on CHERI-RISC-V with heap temporal
safety: aliasing becomes possible only after revocation, ensuring that attempts
to use the old session object fail-stop.</li>
</ol>
<h1><a class="header" href="#answers-4" id="answers-4">Answers</a></h1>
<h2><a class="header" href="#indirect-control-flow-through-aliased-heap-objects-1" id="indirect-control-flow-through-aliased-heap-objects-1">Indirect control flow through aliased heap objects</a></h2>
<ol start="2">
<li>Expected output (addresses may vary):</li>
</ol>
<pre><code>Installing function pointer in obj1 at 0x40809000
Demonstrating use after free:
 First function: 0x40809000
Assigning function pointer through obj2 at 0x40809000
Calling function pointer through obj1 (now 0x40809000):
 Second function: 0x40809000
</code></pre>
<ol start="4">
<li>Expected output (addresses may vary):</li>
</ol>
<pre><code>Installing function pointer in obj1 at v:1 s:0 p:0006817d b:0000000041200040 l:0000000000000040 o:0 t:-1
Demonstrating use after free:
 First function: v:1 s:0 p:0006817d b:0000000041200040 l:0000000000000040 o:0 t:-1
Assigning function pointer through obj2 at v:1 s:0 p:0006817d b:00000000412000c0 l:0000000000000040 o:0 t:-1
Calling function pointer through obj1 (now v:1 s:0 p:0006817d b:0000000041200040 l:0000000000000040 o:0 t:-1):
 First function: v:1 s:0 p:0006817d b:0000000041200040 l:0000000000000040 o:0 t:-1
</code></pre>
<ol start="6">
<li>Expected output (addresses may vary):</li>
</ol>
<pre><code>Installing function pointer in obj1 at v:1 s:0 p:0006817d b:0000000041200040 l:0000000000000040 o:0 t:-1
Demonstrating use after free:
 First function: v:1 s:0 p:0006817d b:0000000041200040 l:0000000000000040 o:0 t:-1
Assigning function pointer through obj2 at v:1 s:0 p:0006817d b:0000000041200040 l:0000000000000040 o:0 t:-1
Calling function pointer through obj1 (now v:1 s:0 p:00000000 b:0000000041200040 l:0000000000000040 o:0 t:-1):
In-address space security exception (core dumped)
</code></pre>
<ol start="7">
<li>The process is attempting a load through a capability with valid tag but no
permissions, as can be readily seen in <code>gdb</code>:</li>
</ol>
<pre><code>Program received signal SIGPROT, CHERI protection violation
Capability permission fault caused by register ca2.
0x0000000000102140 in main ()

(gdb) x/i 0x0000000000102140
=&gt; 0x102140 &lt;main+524&gt;:     lc      ca2,32(a2)

(gdb) p $ca2
$1 = (void *) 0x41200040 [,0x41200040-0x41200080]
</code></pre>
<p><code>malloc_revoke()</code> must have replaced the <code>obj1</code> capability, which previously
had permissions for loading and storing both data and capabilities to the
memory backing <code>obj1</code>, with this permissionless form.</p>
<h1><a class="header" href="#focused-adversarial-missions-1" id="focused-adversarial-missions-1">Focused Adversarial Missions</a></h1>
<h1><a class="header" href="#exploiting-a-buffer-overflow-to-manipulate-control-flow" id="exploiting-a-buffer-overflow-to-manipulate-control-flow">Exploiting a buffer overflow to manipulate control flow</a></h1>
<p>The objective of this mission is to demonstrate arbitrary code execution
through a control-flow attack, despite CHERI protections. You will attack three
different versions of the program:</p>
<ol>
<li>
<p>A baseline RISC-V compilation, to establish that the vulnerability is
exploitable without any CHERI protections.</p>
</li>
<li>
<p>A baseline CHERI-RISC-V compilation, offering strong spacial safety between
heap allocations, including accounting for imprecision in the bounds of large
capabilities.</p>
</li>
<li>
<p>A weakened CHERI-RISC-V compilation, reflecting what would occur if a memory
allocator failed to pad allocations to account for capability bounds
imprecision.</p>
</li>
</ol>
<p>The success condition for an exploit, given attacker-provided input overflowing
a buffer, is to modify control flow in the program such that the <code>success</code>
function is executed.</p>
<ol>
<li>Compile <code>buffer-overflow.c</code> and <code>btpalloc.c</code> together with a RISC-V target
and exploit the binary to execute the <code>success</code> function.</li>
</ol>
<p><strong>buffer-overflow.c</strong></p>
<pre><code class="language-C">/*
 * SPDX-License-Identifier: BSD-2-Clause-DARPA-SSITH-ECATS-HR0011-18-C-0016
 * Copyright (c) 2020 Jessica Clarke
 */
#include &lt;stdint.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include &quot;btpalloc.h&quot;

void
success(void)
{
	puts(&quot;Exploit successful!&quot;);
}

void
failure(void)
{
	puts(&quot;Exploit unsuccessful!&quot;);
}

static uint16_t
ipv4_checksum(uint16_t *buf, size_t words)
{
	uint16_t *p;
	uint_fast32_t sum;

	sum = 0;
	for (p = buf; words &gt; 0; --words, ++p) {
		sum += *p;
		if (sum &gt; 0xffff)
			sum -= 0xffff;
	}

	return (~sum &amp; 0xffff);
}

#include &quot;main-asserts.inc&quot;

int
main(void)
{
	int ch;
	char *buf, *p;
	uint16_t sum;
	void (**fptr)(void);

	buf = btpmalloc(25000);
	fptr = btpmalloc(sizeof(*fptr));

	main_asserts(buf, fptr);

	*fptr = &amp;failure;

	p = buf;
	while ((ch = getchar()) != EOF)
		*p++ = (char)ch;

	if ((uintptr_t)p &amp; 1)
		*p++ = '\0';

	sum = ipv4_checksum((uint16_t *)buf, (p - buf) / 2);
	printf(&quot;Checksum: 0x%04x\n&quot;, sum);

	btpfree(buf);

	(**fptr)();

	btpfree(fptr);

	return (0);
}
</code></pre>
<ol start="2">
<li>Recompile with a CHERI-RISC-V target, attempt to exploit the binary and, if
it cannot be exploited, explain why.</li>
<li>Recompile with a CHERI-RISC-V target but this time adding
<code>-DCHERI_NO_ALIGN_PAD</code>, attempt to exploit the binary and, if it cannot be
exploited, explain why.</li>
</ol>
<p><strong>btpalloc.c</strong></p>
<pre><code class="language-C">/*
 * SPDX-License-Identifier: BSD-2-Clause-DARPA-SSITH-ECATS-HR0011-18-C-0016
 * Copyright (c) 2020 Jessica Clarke
 */
#include &quot;btpalloc.h&quot;

#include &lt;assert.h&gt;
#include &lt;stddef.h&gt;

#include &lt;sys/mman.h&gt;

#ifdef __CHERI_PURE_CAPABILITY__
#include &lt;cheriintrin.h&gt;
#endif

static void *btpmem;
static size_t btpsize;

static void
btpinit(void)
{
	btpsize = 0x100000;
	btpmem = mmap(NULL, btpsize, PROT_READ | PROT_WRITE,
	    MAP_PRIVATE | MAP_ANON, -1, 0);
	assert(btpmem != MAP_FAILED);
}

void *
btpmalloc(size_t size)
{
	void *alloc;
	size_t allocsize;

	if (btpmem == NULL)
		btpinit();

	alloc = btpmem;
	/* RISC-V ABIs require 16-byte alignment */
	allocsize = __builtin_align_up(size, 16);

#if defined(__CHERI_PURE_CAPABILITY__) &amp;&amp; !defined(CHERI_NO_ALIGN_PAD)
	allocsize = cheri_representable_length(allocsize);
	alloc = __builtin_align_up(alloc,
	    ~cheri_representable_alignment_mask(allocsize) + 1);
	allocsize += (char *)alloc - (char *)btpmem;
#endif

	if (allocsize &gt; btpsize)
		return (NULL);

	btpmem = (char *)btpmem + allocsize;
	btpsize -= allocsize;
#ifdef __CHERI_PURE_CAPABILITY__
	alloc = cheri_bounds_set(alloc, size);
#endif
	return (alloc);
}

void
btpfree(void *ptr)
{
	(void)ptr;
}
</code></pre>
<h2><a class="header" href="#support-code-2" id="support-code-2">Support code</a></h2>
<p><strong>btpalloc.h</strong></p>
<pre><code class="language-C">/*
 * SPDX-License-Identifier: BSD-2-Clause-DARPA-SSITH-ECATS-HR0011-18-C-0016
 * Copyright (c) 2020 Jessica Clarke
 */
#include &lt;stddef.h&gt;

void	*btpmalloc(size_t size);
void	 btpfree(void *ptr);
</code></pre>
<p><strong>main-asserts.inc</strong></p>
<pre><code class="language-C">/*
 * SPDX-License-Identifier: BSD-2-Clause-DARPA-SSITH-ECATS-HR0011-18-C-0016
 * Copyright (c) 2020 Jessica Clarke
 */
#include &lt;assert.h&gt;
#include &lt;stdint.h&gt;
#ifdef __CHERI_PURE_CAPABILITY__
#include &lt;cheriintrin.h&gt;
#endif

static void
main_asserts(void *buf, void *fptr)
{
	uintptr_t ubuf = (uintptr_t)buf;
	uintptr_t ufptr = (uintptr_t)fptr;
#ifdef __CHERI_PURE_CAPABILITY__
	ptraddr_t ubuf_top;
#endif

#ifdef __CHERI_PURE_CAPABILITY__
	ubuf_top = cheri_base_get(ubuf) + cheri_length_get(ubuf);
#endif

#if defined(__CHERI_PURE_CAPABILITY__) &amp;&amp; !defined(CHERI_NO_ALIGN_PAD)
	/*
	 * For the normal pure-capability case, `buf`'s allocation should be
	 * adequately padded to ensure precise capability bounds and `fptr`
	 * should be adjacent.
	 */
	assert(ubuf_top == ufptr);
#else
	/*
	 * Otherwise `fptr` should be 8 bytes (not 0 due to malloc's alignment
	 * requirements) after the end of `buf`.
	 */
	assert(ubuf + 25008 == ufptr);
#ifdef __CHERI_PURE_CAPABILITY__
	/*
	 * For pure-capability code this should result in the bounds of the
	 * large `buf` allocation including all of `fptr`.
	 */
	assert(ubuf_top &gt;= ufptr + sizeof(void *));
#endif
#endif
}
</code></pre>
<h1><a class="header" href="#exploiting-an-uninitialized-stack-frame-to-manipulate-control-flow" id="exploiting-an-uninitialized-stack-frame-to-manipulate-control-flow">Exploiting an uninitialized stack frame to manipulate control flow</a></h1>
<p>The objective of this mission is to demonstrate arbitrary code
execution through the use of uninitialized variables on the stack,
despite CHERI protections.  You will attack three different versions
of the program:</p>
<ol>
<li>
<p>A baseline RISC-V compilation, to establish that the vulnerability is
exploitable without any CHERI protections.</p>
</li>
<li>
<p>A hardened CHERI-RISC-V compilation with stack clearing, which
should be non-exploitable.</p>
</li>
<li>
<p>A baseline CHERI-RISC-V compilation with no stack clearing, which
should be non-exploitable due to pointer tagging.</p>
</li>
</ol>
<p>The success condition for an exploit, given attacker-provided input
overriding an on-stack buffer, is to modify control flow in the program
such that the <code>success</code> function is executed.</p>
<h3><a class="header" href="#program-overview" id="program-overview">Program overview</a></h3>
<p>Cookie monster is always hungry for more cookies.  You can sate the
monster's hunger by providing cookies as standard input.  Cookies are
provided as a pair of hexadecimal characters (case is ignored).  Each
cookie is stored at successive bytes in an on-stack character array.
The character array aliases an uninitialized function pointer used in
a subsequent function.  A minus character ('-') can be used to skip
over a character in the array without providing a new cookie.  An
equals sign ('=') can be used to skip over the number of characters in
a pointer without providing any new cookies.  Whitespace is ignored in
the input line.  Input is terminated either by a newline or end of
file (EOF).</p>
<h3><a class="header" href="#building-and-running" id="building-and-running">Building and running</a></h3>
<p>The hardened CHERI-RISC-V version with stack clearing is built by
adding <code>-ftrivial-auto-var-init=zero -enable-trivial-auto-var-init-zero-knowing-it-will-be-removed-from-clang</code>
to the compiler command line.</p>
<h3><a class="header" href="#source-code" id="source-code">Source code</a></h3>
<p><em><strong>stack-mission.c</strong></em></p>
<pre><code class="language-C">/*
 * SPDX-License-Identifier: BSD-2-Clause-DARPA-SSITH-ECATS-HR0011-18-C-0016
 * Copyright (c) 2020 SRI International
 */

#include &lt;assert.h&gt;
#include &lt;ctype.h&gt;
#include &lt;err.h&gt;
#include &lt;stdalign.h&gt;
#include &lt;stddef.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void
success(void)
{
	fprintf(stderr, &quot;Exploit successful, yum!\n&quot;);
	exit(42);
}

void
no_cookies(void)
{
	fprintf(stderr, &quot;No cookies??\n&quot;);
	exit(1);
}

#pragma weak init_pointer
void
init_pointer(void *p)
{
}

static void __attribute__((noinline))
init_cookie_pointer(void)
{
	void *pointers[12];
	void (* volatile cookie_fn)(void);

	for (size_t i = 0; i &lt; sizeof(pointers) / sizeof(pointers[0]); i++)
		init_pointer(&amp;pointers[i]);
	cookie_fn = no_cookies;
}

static void __attribute__((noinline))
get_cookies(void)
{
	alignas(void *) char cookies[sizeof(void *) * 32];
	char *cookiep;
	int ch, cookie;

	printf(&quot;Cookie monster is hungry, provide some cookies!\n&quot;);
	printf(&quot;'=' skips the next %zu bytes\n&quot;, sizeof(void *));
	printf(&quot;'-' skips to the next character\n&quot;);
	printf(&quot;XX as two hex digits stores a single cookie\n&quot;);
	printf(&quot;&gt; &quot;);

	cookiep = cookies;
	for (;;) {
		ch = getchar();

		if (ch == '\n' || ch == EOF)
			break;

		if (isspace(ch))
			continue;

		if (ch == '-') {
			cookiep++;
			continue;
		}

		if (ch == '=') {
			cookiep += sizeof(void *);
			continue;
		}

		if (isxdigit(ch)) {
			cookie = digittoint(ch) &lt;&lt; 4;
			ch = getchar();
			if (ch == EOF)
				errx(1, &quot;Half-eaten cookie, yuck!&quot;);
			if (!isxdigit(ch))
				errx(1, &quot;Malformed cookie&quot;);
			cookie |= digittoint(ch);
			*cookiep++ = cookie;
			continue;
		}

		errx(1, &quot;Malformed cookie&quot;);
	}
}

static void __attribute__((noinline))
eat_cookies(void)
{
	void *pointers[12];
	void (* volatile cookie_fn)(void);

	for (size_t i = 0; i &lt; sizeof(pointers) / sizeof(pointers[0]); i++)
		init_pointer(&amp;pointers[i]);
	cookie_fn();
}

int
main(void)
{
	init_cookie_pointer();
	get_cookies();
	eat_cookies();
	return (0);
}
</code></pre>
<h1><a class="header" href="#exploiting-heap-use-after-free-to-manipulate-control-flow" id="exploiting-heap-use-after-free-to-manipulate-control-flow">Exploiting heap use-after-free to manipulate control flow</a></h1>
<p><strong>This mission requires a CheriBSD sysroot and image with temporal safety!</strong>
The executable can be built for both RISC-V and CHERI-RISC-V (and exploring
both may be worthwhile), but the mission is for CHERI-RISC-V with heap temporal
safety enforcement in place.</p>
<p>This mission is a potted exercise inspired by real-world vulnerabilities where
an active adversary can influence the contents of a server's heap and, often
without completing authentication, walk the server's protocol state machine
through erroneous states. Popular bugs facilitating these exploits include
double free, use-after-reallocation, and type confusion (esp. of temporally
aliased objects). For this mission, we have simplified the interface to be a
little &quot;command language&quot; read over <code>stdin</code>, detailed below.</p>
<p>The success criterion is executing the <code>success</code> function. To ease testing,
this is the only case in which the program source claims to exit with a code of
<code>42</code>. Ordinary termination is signaled with <code>0</code> and invalid input results in
the program terminating with <code>1</code>. While the source does not overtly claim any
other outcome, if control flow can be redirected, almost anything goes.</p>
<h3><a class="header" href="#program-overview-1" id="program-overview-1">Program Overview</a></h3>
<p>This is a (very) minimal simulation of a program that manages multiple
sessions, objects within each session, and limited information flow between
those sessions. Rather than network sockets, each session is represented by a
<code>struct farm</code> and there are up to four such active at any moment. Within each
<code>struct farm</code> is a circular collection of <code>struct crop</code>s, at most one of which
may be selected by the <code>cursor</code> of its owning <code>struct farm</code>. If no crop is
selected, the cursor is said to be &quot;in the gap&quot;. The crop at the cursor, if
any, can be asked to describe itself, using a function pointer within the
<code>struct crop</code> itself.</p>
<p>To make matters more exciting, a UFO may be summoned to perform particular
kinds of mischief. The UFO may &quot;abduct&quot; a pointer into itself and can create
crop signs within <code>struct crop</code> (with data) or <code>struct farm</code> (with a capability
to the <code>success()</code> function).</p>
<p>The gadgets offered by the UFO are somewhat limited (that is, they are not
&quot;write what where&quot; or arbitrary control transfer) as one might expect to see in
a real application. Nevertheless, they are sufficiently powerful to provide
<em>myriad</em> exploitation vectors on RISC-V without CHERI, and even a few on
CHERI-RISC-V. However, we believe that enforced heap temporal safety will
ensure that any use of them is either overwritten by subsequent program
operations before the gadgets' effects influence control flow or will cause the
program to fail-stop with a default-fatal signal (e.g., <code>SIGSEGV</code> or
<code>SIGPROT</code>).</p>
<h3><a class="header" href="#building-and-running-1" id="building-and-running-1">Building and running</a></h3>
<p>We suggest using the <code>ccc</code> tool provided with this book, building for
<code>riscv64-purecap</code>. For experimentation, this program also builds for
<code>riscv64</code>, without CHERI. On <code>riscv64-purecap</code> builds, heap temporal safety
enforcement may be disabled at program load time by setting the environment
variable <code>MALLOC_DISABLE_REVOCATION</code> to a non-empty value. (While setting this
flag prior to program loading disqualifies such invocations from completing the
mission, being able to disable revocation from within <code>main()</code> would be quite
interesting indeed.)</p>
<p>As said before, the program expects to read a command language from <code>stdin</code>.
It will print &quot;Ready&quot; and then await input. Unlike real applications, this
program is fairly chatty about its own operation to ease exploration.
Nevertheless, it may be useful to run it within <code>gdb</code>, especially to
differentiate causes of crashes.</p>
<h3><a class="header" href="#command-language-directives" id="command-language-directives">Command Language Directives</a></h3>
<ul>
<li>
<p>Whitespace is quietly ignored in most cases; this may simplify reading
programs.</p>
</li>
<li>
<p>Digits <code>0</code> through <code>3</code> focus on the corresponding farm slots, making it the
locus of subsequent commands until altered.</p>
</li>
<li>
<p><code>F</code> allocates a new farm at the current slot.</p>
</li>
<li>
<p><code>f</code> frees the current slot's farm (along with any crops in its collection)</p>
</li>
<li>
<p><code>C</code> creates a new crop in the current farm and puts it at the left of the
collection. The cursor is left in the gap or pointing at the crop it was
before. If the cursor is not in the gap, the new crop will inherit the
description of the selected crop; otherwise, the program chooses one of two
varieties of cherry.</p>
</li>
<li>
<p><code>L</code> and <code>R</code> move the current farm's cursor left and right, respectively. The
farm's collection is circular with a gap; moving left (right) from the gap
places the cursor at the rightmost (leftmost) element, and walking off either
end returns the cursor to the gap.</p>
</li>
<li>
<p><code>Z</code> moves the current farm's cursor to the gap.</p>
</li>
<li>
<p><code>D</code> describes the crop at the current farm's cursor, if that cursor is not in
the gap.</p>
</li>
<li>
<p><code>c</code> removes the crop at the current farm's cursor from the collection and
frees it.</p>
</li>
<li>
<p><code>U</code> causes a UFO to arrive; <code>u</code> causes it to leave. There is at most one UFO
at any moment.</p>
</li>
<li>
<p><code>A</code> causes the UFO, if present, to abduct the current farm's cursor,
presumably for further scrutiny.</p>
</li>
<li>
<p><code>S</code> causes the UFO to make a crop sign on the current farm; <code>s</code> causes the
UFO to read the next <code>sizeof(void*)</code> characters from <code>stdin</code> (whitespace is
not ignored for this) and use that to sign the crop indicated by the current
farm's cursor (a smaller crop sign, if you will). Writing crop signs of
either variety is very destabilizing and likely to lead to crashes!</p>
</li>
<li>
<p>On CHERI-RISC-V builds running with heap temporal safety enforcement, <code>!</code>
will force a revocation pass, destroying pointers to free objects and
allowing reuse of memory and address space.</p>
</li>
</ul>
<h3><a class="header" href="#example-session" id="example-session">Example Session</a></h3>
<p>Here is a short session which creates one <code>struct farm</code>, two <code>struct crop</code>s,
exhibits cursor control and description of <code>struct crop</code>s, and then tears down
the <code>struct farm</code>:</p>
<pre><code>$ echo FCC RD ZLD f | ./temporal-mission
Ready (CHERI-RISC-V)
New farm (index 0) at 0x41201080
New crop at 0x41201100
New crop at 0x41201180
Farm 0 cursor 0x41201180
FYI: Current farm is 0x41201080
FYI:  cursor 0x41201180
FYI:  cursor-&gt;describe 0x102fd2
Chelan at 0x41201180
Farm 0 cursor 0x41201100
FYI: Current farm is 0x41201080
FYI:  cursor 0x41201100
FYI:  cursor-&gt;describe 0x10300e
Colt at 0x41201100
Tear down farm (index 0) at 0x41201080
</code></pre>
<h3><a class="header" href="#source-code-1" id="source-code-1">Source code</a></h3>
<p><strong>temporal-mission.c</strong></p>
<pre><code class="language-C">/*
 * SPDX-License-Identifier: BSD-2-Clause
 * Copyright (c) 2020 Microsoft, Inc.
 */
#include &lt;assert.h&gt;
#include &lt;ctype.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#include &lt;sys/queue.h&gt;

#if defined(__CHERI_PURE_CAPABILITY__)
#include &lt;cheri/revoke.h&gt;
static void __attribute__((used)) *check_cheri_revoke = cheri_revoke;
extern void malloc_revoke(void);
static void __attribute__((used)) *check_malloc_revoke = malloc_revoke;
#endif

struct farm;
struct crop;

static void
success(struct farm *f)
{
	fprintf(stderr, &quot;Exploit successful: computer bought the farm!\n&quot;);
	exit(42);
}

TAILQ_HEAD(cropq, crop);

struct farm {
	struct cropq	cropq;
	struct crop	*cursor;
};

struct crop {
	void			(*describe)(struct crop *);
	TAILQ_ENTRY(crop)	farm_cropq;
};

_Static_assert(sizeof(struct crop) == sizeof(struct farm),
    &quot;Structure size mismatch&quot;);

union ufo {
	void	*ptrA;
	char	buf[sizeof(struct crop)];
};

_Static_assert(sizeof(struct crop) == sizeof(union ufo),
    &quot;Structure size mismatch&quot;);

static void
descr_1(struct crop *c)
{
	fprintf(stderr, &quot;Chelan at %p\n&quot;, c); /* Pacific Northwest */
}

static void
descr_2(struct crop *c)
{
	fprintf(stderr, &quot;Colt at %p\n&quot;, c); /* United Kingdom */
}

static unsigned int cid;
static union ufo *ufo;

#define NFARM 4
struct farm *farmp[NFARM];

static void
rm_farm(int fix)
{
	struct farm *f = farmp[fix];

	farmp[fix] = NULL;
	if (f != NULL) {
		struct crop *c, *tc;

		TAILQ_FOREACH_SAFE(c, &amp;f-&gt;cropq, farm_cropq, tc) {
			TAILQ_REMOVE(&amp;f-&gt;cropq, c, farm_cropq);
			free(c);
		}

		fprintf(stderr, &quot;Tear down farm (index %d) at %p\n&quot;, fix, f);
		free(f);
	}
}

static struct farm *
mk_farm(int fix)
{
	struct farm *f;

	rm_farm(fix);

	f = malloc(sizeof(struct farm));
	assert(f != NULL); /* Surely infinite memory */

	TAILQ_INIT(&amp;f-&gt;cropq);
	f-&gt;cursor = NULL;

	farmp[fix] = f;

	fprintf(stderr, &quot;New farm (index %d) at %p\n&quot;, fix, f);
	return f;
}

static void
rm_crop(struct farm *f, struct crop *c)
{
	fprintf(stderr, &quot;Del crop at %p\n&quot;, c);
	TAILQ_REMOVE(&amp;f-&gt;cropq, c, farm_cropq);
	free(c);
}

static struct crop *
mk_crop(struct farm *f)
{
	struct crop *c;

	c = malloc(sizeof(struct crop));
	assert(c != NULL);

	if (f-&gt;cursor != NULL) {
		/* Inherit description of current cursor */
		c-&gt;describe = f-&gt;cursor-&gt;describe;
	} else {
		c-&gt;describe = (cid &amp; 1) ? descr_1 : descr_2 ;
	}
	cid++;

	TAILQ_INSERT_HEAD(&amp;f-&gt;cropq, c, farm_cropq);

	fprintf(stderr, &quot;New crop at %p\n&quot;, c);

	return c;
}

static void
rm_ufo(void)
{
	if (ufo != NULL) {
		fprintf(stderr, &quot;Del UFO at %p\n&quot;, ufo);
		free(ufo);
	}
}

int
main(void)
{
	int c;
	size_t fix = 0;

#if defined(__CHERI_PURE_CAPABILITY__)
	if (getenv(&quot;MALLOC_DISABLE_REVOCATION&quot;) == NULL) {
		fprintf(stderr, &quot;Ready (CHERI-RISC-V)\n&quot;);
	} else {
		fprintf(stderr, &quot;Ready (CHERI-RISC-V, reduced heap safety)\n&quot;);
	}
#else
	fprintf(stderr, &quot;Ready (RISC-V)\n&quot;);
#endif

	while ((c = getchar()) != EOF) {
		if (isspace(c))
			continue;

		if (('0' &lt;= c) &amp;&amp; (c &lt; '0' + NFARM)) {
			fix = c - '0';
			fprintf(stderr, &quot;Selected farm %zu (%p)\n&quot;, fix,
			    farmp[fix]);
			continue;
		}

		struct farm *f = farmp[fix];
		switch (c) {
		case '!':
#if defined(__CHERI_PURE_CAPABILITY__)
			malloc_revoke();
#else
			fprintf(stderr, &quot;No revocation without CHERI!\n&quot;);
#endif
			break;

		/* Crop management */
		case 'C':
			if (f != NULL)
				mk_crop(f);
			break;
		case 'c':
			if ((f != NULL) &amp;&amp; (f-&gt;cursor != NULL))
				rm_crop(f, f-&gt;cursor);
			break;
		case 'D':
			fprintf(stderr, &quot;FYI: Current farm is %p\n&quot;, f);
			if ((f != NULL) &amp;&amp; (f-&gt;cursor != NULL)) {
				fprintf(stderr, &quot;FYI:  cursor %p\n&quot;, f-&gt;cursor);
				fprintf(stderr, &quot;FYI:  cursor-&gt;describe %p\n&quot;,
				    f-&gt;cursor-&gt;describe);
				f-&gt;cursor-&gt;describe(f-&gt;cursor);
			}
			break;

		/* Farm management */
		case 'F':
			mk_farm(fix);
			break;
		case 'f':
			rm_farm(fix);
			break;

		/* Cursor control */
		case 'L':
			if (f != NULL) {
				if (f-&gt;cursor != NULL) {
					f-&gt;cursor = TAILQ_PREV(f-&gt;cursor, cropq,
					    farm_cropq);
				} else {
					f-&gt;cursor = TAILQ_LAST(&amp;f-&gt;cropq,
					    cropq);
				}
			}
			fprintf(stderr, &quot;Farm %zu cursor %p\n&quot;, fix, f-&gt;cursor);
			break;
		case 'R':
			if (f != NULL) {
				if (f-&gt;cursor != NULL) {
					f-&gt;cursor = TAILQ_NEXT(f-&gt;cursor,
					    farm_cropq);
				} else {
					f-&gt;cursor = TAILQ_FIRST(&amp;f-&gt;cropq);
				}
			}
			fprintf(stderr, &quot;Farm %zu cursor %p\n&quot;, fix, f-&gt;cursor);
			break;
		case 'Z':
			if (f != NULL)
				f-&gt;cursor = NULL;
			break;

		/* UFO control sequences */
		case 'A':
			if ((ufo != NULL) &amp;&amp; (f != NULL)) {
				fprintf(stderr, &quot;UFO abduct %p\n&quot;, f-&gt;cursor);
				ufo-&gt;ptrA = f-&gt;cursor;
			}
			break;
		case 'S':
			if (f != NULL) {
				/* Jess's Organic Farm-to-Vtable Capability */
				fprintf(stderr, &quot;Crop sign at farm %p\n&quot;, f);
				f-&gt;cursor = (void *)success;
			}
			break;
		case 's':
			if ((f != NULL) &amp;&amp; (f-&gt;cursor != NULL)) {
				char buf[sizeof(void *)];
				for (size_t i = 0; i &lt; sizeof buf; i++) {
					buf[i] = getchar();
				}
				fprintf(stderr, &quot;Signing crop %p\n&quot;, f-&gt;cursor);
				memmove((char *)f-&gt;cursor, buf, sizeof(buf));
			}
			break;
		case 'U':
			rm_ufo();
			ufo = malloc(sizeof(union ufo));
			assert(ufo != NULL);
			fprintf(stderr, &quot;UFO at %p\n&quot;, ufo);
			break;
		case 'u':
			rm_ufo();
			break;

		default:
			fprintf(stderr, &quot;Did not understand %x; bail!\n&quot;, c);
			return 1;
		}
	}

	return 0;
}
</code></pre>
<h1><a class="header" href="#exploit-vulnerability-freebsd-sa-0906ktimer-kernel-buffer-overflow" id="exploit-vulnerability-freebsd-sa-0906ktimer-kernel-buffer-overflow">Exploit vulnerability FreeBSD-SA-09:06.ktimer: kernel buffer overflow</a></h1>
<p>This mission depends on the pure-capability CheriBSD FETT kernel included in FETT CHERI-RISC-V Release 2 (kernel spatial memory safety).</p>
<p>The objective of this mission is to demonstrate arbitrary code execution in a pure-capability kernel.
This must be achieved via a reintroduced past FreeBSD security vulnerability, <a href="https://www.freebsd.org/security/advisories/FreeBSD-SA-09:06.ktimer.asc">FreeBSD-SA-09:06.ktimer</a>.
We have reintroduced this via change <a href="https://github.com/CTSRD-CHERI/cheribsd/commit/69bb6a5e55fc94dd7338e22492971edbf55f8393">69bb6a5e55fc94dd7338e22492971edbf55f8393</a> in the pure-capability kernel branch of the CheriBSD repository.
In this vulnerability, an integer system-call argument is not properly bounds checked, allowing an out-of-bounds access that on a vanilla non-CHERI system is exploitable to gain kernel privilege.
More information on the timer system-call interface can be found in the <a href="https://www.freebsd.org/cgi/man.cgi?query=timer_settime&amp;sektion=2"><code>timer_settime(2)</code></a> and related man pages.</p>
<p>Successful completion of this mission requires demonstrating that the kernel function <code>flag_captured(9)</code> has executed with the integer argument <code>0xfe77c0de</code> using one of the <code>ktimer(2)</code> system calls triggered as an unprivileged (non-root) user.
Use of privileged kernel manipulation mechanisms, such as reconfiguration of the boot-time environment, use of the kernel debugger, kernel module loading, and access to <code>/dev/mem</code>, is considered out-of-scope in this mission.
If <code>flag_captured(9)</code> is called, the sysctl <code>security.kernel_flags_captured</code> counter will be incremented.
This corresponds to a partially successful exploit.
If the function is called with the designated argument, the sysctl <code>security.kernel_flags_captured_key</code> counter will be incremented.
This corresponds to a fully successful exploit.</p>
<h1><a class="header" href="#exploit-vulnerability-freebsd-sa-1813nfs-out-of-bounds-access" id="exploit-vulnerability-freebsd-sa-1813nfs-out-of-bounds-access">Exploit vulnerability FreeBSD-SA-18:13.nfs: out-of-bounds access</a></h1>
<p>This mission depends on the pure-capability CheriBSD FETT kernel included in FETT CHERI-RISC-V Release 2 (kernel spatial memory safety).</p>
<p>The objective of this mission is to demonstrate arbitrary code execution in a pure-capability kernel.
This must be achieved via a reintroduced past FreeBSD security vulnerability, <a href="https://www.freebsd.org/security/advisories/FreeBSD-SA-18:13.nfs.asc">FreeBSD-SA-18:13.nfs</a>.
We have reintroduced this via change <a href="https://github.com/CTSRD-CHERI/cheribsd/commit/015fdfd5a71c299c6288e1d789735ef6d3b46329">015fdfd5a71c299c6288e1d789735ef6d3b46329</a> in the pure-capability kernel branch of the CheriBSD repository.
In this vulnerability, an out-of-bounds access is performed during received NFS packet processing, which is exploitable on a vanilla non-CHERI system to gain kernel privilege.
More information on the NFSv4 packet format may be found in <a href="https://tools.ietf.org/html/rfc7530">RFC7530</a>.</p>
<p>Successful completion of this mission requires demonstrating that the kernel function <code>flag_captured(9)</code> has executed with the integer argument <code>0xfe77c0de</code> using the use of an NFS packet exploiting this vulnerability.
Use of privileged kernel manipulation mechanisms, such as reconfiguration of the boot-time environment, use of the kernel debugger, kernel module loading, and access to <code>/dev/mem</code>, is considered out-of-scope in this mission.
If <code>flag_captured(9)</code> is called, the sysctl <code>security.flags_captured</code> counter will be incremented.
This corresponds to a partially successful exploit.
If the function is called with the designated argument, the sysctl <code>security.flags_captured_key</code> counter will be incremented.
This corresponds to a fully successful exploit.</p>
<h1><a class="header" href="#appendix" id="appendix">Appendix</a></h1>
<p>This book and related source code are released under the following license:</p>
<pre><code>SPDX-License-Identifier: BSD-2-Clause-DARPA-SSITH-ECATS-HR0011-18-C-0016

Copyright (c) 2020 Jessica Clarke
Copyright (c) 2020, 2022 Robert N. M. Watson
Copyright (c) 2020 SRI International
Copyright (c) 2022 Microsoft Corporation

This software was developed by SRI International and the University of
Cambridge Computer Laboratory (Department of Computer Science and
Technology) under DARPA contract HR0011-18-C-0016 (&quot;ECATS&quot;), as part of the
DARPA SSITH research programme.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
SUCH DAMAGE.
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
